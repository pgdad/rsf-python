# DO NOT EDIT - Generated by RSF v0.1.0 on 2026-02-26T17:59:04Z
# Source: examples/retry-and-recovery/workflow.yaml (SHA-256: dc366cacdaa00e16220f4a07665f13a569770480c7c4803c66839c1989117a7a)

from aws_lambda_durable_execution_sdk_python import DurableContext, durable_execution
from aws_lambda_durable_execution_sdk_python.config import Duration
from rsf.registry import get_handler, get_startup_hooks
import handlers.call_primary_service
import handlers.verify_result
import handlers.try_fallback_service
import handlers.handle_bad_data
import handlers.retry_after_throttle


class WorkflowError(Exception):
    """Raised by Fail states in the workflow."""

    def __init__(self, error: str, cause: str | None = None):
        self.error = error
        self.cause = cause
        super().__init__(f"{error}: {cause}" if cause else error)


_startup_done = False


@durable_execution
def lambda_handler(context: DurableContext, event: dict) -> dict:
    global _startup_done
    if not _startup_done:
        for hook in get_startup_hooks():
            hook()
        _startup_done = True

    current_state = 'CallPrimaryService'
    input_data = event

    while current_state is not None:
        if current_state == 'CallPrimaryService':
            try:
                handler = get_handler('CallPrimaryService')
                input_data = context.step('CallPrimaryService', handler, input_data)
                current_state = 'VerifyResult'
            except Exception as _err:
                if type(_err).__name__ in ['ServiceDownError'] or "States.ALL" in ['ServiceDownError']:
                    input_data = _apply_error_result(input_data, _err, '$.primaryError')
                    current_state = 'TryFallbackService'
                elif type(_err).__name__ in ['RateLimitError'] or "States.ALL" in ['RateLimitError']:
                    input_data = _apply_error_result(input_data, _err, '$.throttleError')
                    current_state = 'HandleThrottle'
                elif type(_err).__name__ in ['DataValidationError'] or "States.ALL" in ['DataValidationError']:
                    input_data = _apply_error_result(input_data, _err, '$.validationError')
                    current_state = 'HandleBadData'
                elif type(_err).__name__ in ['States.ALL'] or "States.ALL" in ['States.ALL']:
                    input_data = _apply_error_result(input_data, _err, '$.error')
                    current_state = 'CriticalFailure'
                else:
                    raise

        elif current_state == 'VerifyResult':
            handler = get_handler('VerifyResult')
            input_data = context.step('VerifyResult', handler, input_data)
            current_state = 'ServiceComplete'

        elif current_state == 'TryFallbackService':
            try:
                handler = get_handler('TryFallbackService')
                input_data = context.step('TryFallbackService', handler, input_data)
                current_state = 'VerifyResult'
            except Exception as _err:
                if type(_err).__name__ in ['States.ALL'] or "States.ALL" in ['States.ALL']:
                    input_data = _apply_error_result(input_data, _err, '$.error')
                    current_state = 'CriticalFailure'
                else:
                    raise

        elif current_state == 'HandleThrottle':
            current_state = 'RetryAfterThrottle'

        elif current_state == 'HandleBadData':
            try:
                handler = get_handler('HandleBadData')
                input_data = context.step('HandleBadData', handler, input_data)
                current_state = 'CallPrimaryService'
            except Exception as _err:
                if type(_err).__name__ in ['States.ALL'] or "States.ALL" in ['States.ALL']:
                    input_data = _apply_error_result(input_data, _err, '$.error')
                    current_state = 'CriticalFailure'
                else:
                    raise

        elif current_state == 'CriticalFailure':
            raise WorkflowError('CriticalFailure', 'All recovery attempts exhausted')

        elif current_state == 'ServiceComplete':
            return input_data

        elif current_state == 'RetryAfterThrottle':
            try:
                handler = get_handler('RetryAfterThrottle')
                input_data = context.step('RetryAfterThrottle', handler, input_data)
                current_state = 'VerifyResult'
            except Exception as _err:
                if type(_err).__name__ in ['States.ALL'] or "States.ALL" in ['States.ALL']:
                    input_data = _apply_error_result(input_data, _err, '$.error')
                    current_state = 'CriticalFailure'
                else:
                    raise

        else:
            raise RuntimeError(f"Unknown state: {current_state}")

    return input_data


def _resolve_path(data: dict, path: str) -> object:
    """Resolve a simple JSONPath reference ($.field.sub) against data."""
    if path == "$":
        return data
    parts = path.lstrip("$.").split(".")
    current: object = data
    for part in parts:
        if isinstance(current, dict):
            current = current[part]
        else:
            raise KeyError(f"Cannot resolve path '{path}' in {type(current)}")
    return current


def _apply_result_path(data: dict, result: object, path: str) -> dict:
    """Apply a result to data at the given path."""
    import copy
    if path == "$":
        return result if isinstance(result, dict) else {"result": result}
    output = copy.deepcopy(data)
    parts = path.lstrip("$.").split(".")
    current = output
    for part in parts[:-1]:
        if part not in current:
            current[part] = {}
        current = current[part]
    current[parts[-1]] = result
    return output


def _apply_error_result(data: dict, error: Exception, path: str) -> dict:
    """Apply error info to data at the given path."""
    error_info = {"Error": type(error).__name__, "Cause": str(error)}
    return _apply_result_path(data, error_info, path)


def _string_matches(value: str, pattern: str) -> bool:
    """Match a string against an ASL StringMatches pattern (* wildcard)."""
    import re
    regex = "^" + re.escape(pattern).replace(r"\*", ".*") + "$"
    return bool(re.match(regex, value))


def _is_present(data: dict, path: str) -> bool:
    """Check if a JSONPath exists in the data."""
    try:
        _resolve_path(data, path)
        return True
    except (KeyError, TypeError):
        return False


def _is_timestamp(value: object) -> bool:
    """Check if a value looks like an ISO 8601 timestamp."""
    if not isinstance(value, str):
        return False
    try:
        from datetime import datetime
        datetime.fromisoformat(value.replace("Z", "+00:00"))
        return True
    except (ValueError, AttributeError):
        return False
