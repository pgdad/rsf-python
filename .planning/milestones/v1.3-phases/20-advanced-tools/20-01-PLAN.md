---
phase: 20-advanced-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorials/06-asl-import.md
autonomous: true
requirements:
  - MIGR-01

must_haves:
  truths:
    - "User can run rsf import on a real ASL JSON file and receive RSF YAML output plus handler stubs"
    - "User understands the conversion rules: Resource removal, Fail I/O stripping, Iterator→ItemProcessor rename"
    - "User can immediately validate and generate from the imported RSF YAML without manual fixups"
  artifacts:
    - path: "tutorials/06-asl-import.md"
      provides: "Step-by-step rsf import tutorial with sample ASL input, conversion output walkthrough, and handler stub explanation"
      min_lines: 200
  key_links:
    - from: "tutorials/06-asl-import.md"
      to: "src/rsf/cli/import_cmd.py"
      via: "Documents the exact behavior of rsf import"
      pattern: "rsf import"
    - from: "tutorials/06-asl-import.md"
      to: "src/rsf/importer/converter.py"
      via: "Documents the ASL-to-RSF conversion rules"
      pattern: "convert_asl_to_rsf"
---

<objective>
Create a comprehensive step-by-step tutorial for `rsf import` that walks users through converting an existing AWS Step Functions ASL JSON definition to RSF YAML with auto-generated handler stubs.

Purpose: Users migrating from AWS Step Functions need a hands-on guide to import their existing ASL definitions, understand the conversion rules and warnings, review the generated RSF YAML and handler stubs, and immediately validate and generate from the imported workflow.
Output: `tutorials/06-asl-import.md` — a complete tutorial document.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/rsf/cli/import_cmd.py
@src/rsf/importer/converter.py
@tutorials/01-project-setup.md
@tutorials/05-iterate-invoke-teardown.md

<interfaces>
<!-- The rsf import command behavior (from src/rsf/cli/import_cmd.py):

  Arguments:
    asl_file: Path to ASL JSON file (required)

  Options:
    --output / -o: Output YAML file path (default: "workflow.yaml")
    --handlers: Handler stubs output directory (default: "handlers")

  Pipeline:
  1. Check ASL file exists → "Error: ASL file not found: {path}"
  2. Warn if output file already exists → "Warning: Output file already exists and will be overwritten: {path}"
  3. Call import_asl() which:
     a. Parses ASL JSON
     b. Converts to RSF format (applying conversion rules)
     c. Emits YAML to output_path
     d. Generates handler stubs for Task states in handlers_dir
  4. Print any conversion warnings:
     - "Warning: State 'X' has a Resource field ('arn:...'). RSF does not use Resource — use @state decorators..."
     - "Warning: Renamed legacy 'Iterator' to 'ItemProcessor' in state 'X'."
     - "Warning: Distributed Map field 'ItemReader' in state 'X' is not supported..."
  5. Print success summary:
     - "Success: Converted ASL to {output}"
     - "  Handler stubs: N created in {handlers_dir}/"
     - "    - StateName1"
     - "    - StateName2"

  Conversion rules (from converter.py):
  1. Inject rsf_version: "1.0" at root
  2. Reject Resource field with guidance (removed, warning printed)
  3. Strip Fail state I/O fields (ASL allows them, RSF rejects them)
  4. Rename legacy Iterator → ItemProcessor for Map states
  5. Warn on distributed Map fields (ItemReader, ItemBatcher, ResultWriter) — removed
  6. Recursive conversion for Parallel branches and Map ItemProcessor
  7. Collect Task state names → generate handler stubs via codegen
-->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the rsf import tutorial</name>
  <files>tutorials/06-asl-import.md</files>
  <action>
Create the file `tutorials/06-asl-import.md` with the following structure and content:

**Title:** "Tutorial 6: Importing ASL Workflows with `rsf import`"

**Sections to include (in order):**

1. **What You'll Learn** — Brief overview: import an existing AWS Step Functions ASL JSON definition into RSF, understand the conversion rules and warnings, review the generated YAML and handler stubs, and validate the imported workflow.

2. **Prerequisites** —
   - RSF installed (`pip install rsf`)
   - Familiarity with AWS Step Functions ASL (Amazon States Language) JSON format
   - No AWS account needed — this tutorial works entirely offline

3. **Step 1: Create a Sample ASL Definition** — Have the user create a file called `order-processing.asl.json` with a realistic ASL definition that exercises multiple conversion rules. Use this exact JSON:
   ```json
   {
     "Comment": "Order processing workflow",
     "StartAt": "ValidateOrder",
     "States": {
       "ValidateOrder": {
         "Type": "Task",
         "Resource": "arn:aws:lambda:us-east-2:123456789012:function:validate-order",
         "Next": "CheckAmount"
       },
       "CheckAmount": {
         "Type": "Choice",
         "Choices": [
           {
             "Variable": "$.amount",
             "NumericGreaterThan": 100,
             "Next": "RequireApproval"
           }
         ],
         "Default": "ProcessOrder"
       },
       "RequireApproval": {
         "Type": "Task",
         "Resource": "arn:aws:lambda:us-east-2:123456789012:function:require-approval",
         "Next": "ProcessOrder"
       },
       "ProcessOrder": {
         "Type": "Task",
         "Resource": "arn:aws:lambda:us-east-2:123456789012:function:process-order",
         "Next": "NotifyComplete"
       },
       "NotifyComplete": {
         "Type": "Succeed"
       }
     }
   }
   ```
   Explain: this is a standard ASL definition with Task states that reference Lambda ARNs via the `Resource` field, a Choice state for routing, and a Succeed terminal state. In AWS Step Functions, the `Resource` field tells the service which Lambda to invoke. In RSF, handler routing uses `@state` decorators instead.

4. **Step 2: Run the Import** — Show the exact command:
   ```bash
   rsf import order-processing.asl.json
   ```
   Show expected output:
   ```
   Warning: State 'ValidateOrder' has a Resource field ('arn:aws:lambda:us-east-2:123456789012:function:validate-order'). RSF does not use Resource — use @state decorators to register handlers instead. The Resource field has been removed.
   Warning: State 'RequireApproval' has a Resource field ('arn:aws:lambda:us-east-2:123456789012:function:require-approval'). RSF does not use Resource — use @state decorators to register handlers instead. The Resource field has been removed.
   Warning: State 'ProcessOrder' has a Resource field ('arn:aws:lambda:us-east-2:123456789012:function:process-order'). RSF does not use Resource — use @state decorators to register handlers instead. The Resource field has been removed.
   Success: Converted ASL to workflow.yaml
     Handler stubs: 3 created in handlers/
       - ValidateOrder
       - RequireApproval
       - ProcessOrder
   ```
   Explain: the warnings are expected — RSF removes the `Resource` field from each Task state because RSF uses `@state` decorators instead of Lambda ARNs. Three handler stubs were created (one per Task state). The Choice and Succeed states do not get handler stubs.

5. **Step 3: Review the Generated YAML** — Show the generated `workflow.yaml` content. It should look like:
   ```yaml
   rsf_version: '1.0'
   Comment: Order processing workflow
   StartAt: ValidateOrder
   States:
     ValidateOrder:
       Type: Task
       Next: CheckAmount
     CheckAmount:
       Type: Choice
       Choices:
       - Variable: $.amount
         NumericGreaterThan: 100
         Next: RequireApproval
       Default: ProcessOrder
     RequireApproval:
       Type: Task
       Next: ProcessOrder
     ProcessOrder:
       Type: Task
       Next: NotifyComplete
     NotifyComplete:
       Type: Succeed
   ```
   Point out the differences from the original ASL:
   - `rsf_version: "1.0"` added at the top
   - All `Resource` fields removed from Task states
   - Everything else preserved as-is (structure, field names, values)

6. **Step 4: Review the Handler Stubs** — Show the directory listing and the content of one generated handler stub (`handlers/validate_order.py`). The stub contains the `@state("ValidateOrder")` decorator and a placeholder function body. Explain:
   - One stub per Task state: `validate_order.py`, `require_approval.py`, `process_order.py`
   - The function name is the snake_case version of the state name
   - The `@state` decorator replaces the ASL `Resource` field — this is how RSF knows which function handles which state
   - The stub body has a TODO placeholder — replace it with your business logic (port from your original Lambda functions)

7. **Step 5: Validate the Imported Workflow** — Run `rsf validate` on the generated file:
   ```bash
   rsf validate workflow.yaml
   ```
   Show expected output (validation passes). Explain: the import pipeline produces valid RSF YAML — no manual fixups needed.

8. **Step 6: Generate and Continue** — Run `rsf generate` to regenerate the orchestrator:
   ```bash
   rsf generate
   ```
   Explain: the imported workflow is now fully integrated into the RSF pipeline. From here, follow the same workflow as Tutorials 3-5: customize handlers, deploy, iterate.

9. **Understanding Conversion Rules** — A reference section summarizing all conversion rules:
   - **Resource removal**: ASL Task states reference Lambda ARNs via `Resource`. RSF removes this field and generates `@state` handler stubs instead.
   - **Fail state I/O stripping**: ASL allows I/O fields (InputPath, OutputPath, etc.) on Fail states. RSF's strict validation rejects them, so they are silently stripped.
   - **Iterator to ItemProcessor**: Legacy Map states use `Iterator` instead of `ItemProcessor`. RSF renames it automatically.
   - **Distributed Map fields**: `ItemReader`, `ItemBatcher`, `ResultWriter` are AWS-specific distributed Map features. RSF removes them with a warning.
   - **Recursive conversion**: Parallel branches and Map ItemProcessor sub-workflows are converted recursively — nested Task states get handler stubs too.

   > **Note:** If your ASL uses features not supported by RSF (such as distributed Map), review the warnings carefully. The unsupported fields are removed, and you may need to restructure that part of your workflow.

10. **Importing with Custom Output Paths** — Show the `--output` and `--handlers` options:
    ```bash
    rsf import order-processing.asl.json --output my-workflow.yaml --handlers my-handlers
    ```
    Explain: by default, `rsf import` writes to `workflow.yaml` and `handlers/`. Use these options to customize the output paths.

11. **What's Next** — Point to Tutorial 7 (rsf ui) for visually editing the imported workflow in the graph editor. Mention that the imported workflow can also be deployed to AWS following Tutorials 4-5.

**Style guidelines (follow exactly):**
- Follow the established tutorial patterns from Tutorials 1-5
- Use clear, direct language. No marketing fluff.
- Every command should be in a fenced code block with `bash` syntax highlighting.
- Every file listing should be in a fenced code block with appropriate syntax highlighting (json, yaml, python).
- Use blockquotes (> ) for important notes or tips.
- Keep explanations concise — 2-4 sentences per concept.
- Do NOT use emojis.
- The ASL JSON sample must be valid JSON that the converter can actually process.
- The generated YAML shown must match what `emit_yaml()` would actually produce (block style, no flow style, keys unsorted).
  </action>
  <verify>
    <automated>test -f tutorials/06-asl-import.md && wc -l tutorials/06-asl-import.md | awk '{if ($1 >= 200) print "PASS: "$1" lines"; else print "FAIL: only "$1" lines"}'</automated>
  </verify>
  <done>
    - tutorials/06-asl-import.md exists with 200+ lines
    - Tutorial covers: creating an ASL JSON file, running rsf import, reviewing generated YAML and handler stubs, validating the imported workflow, generating code, conversion rules reference, custom output paths
    - Resource removal warnings shown with exact format matching import_cmd.py
    - All 6 conversion rules documented in reference section
    - Handler stub walkthrough with @state decorator explanation
    - rsf validate shows the imported workflow passes validation
    - Pointer to Tutorial 7 (rsf ui)
  </done>
</task>

</tasks>

<verification>
1. `tutorials/06-asl-import.md` exists and has 200+ lines
2. Tutorial documents rsf import command with correct arguments and options
3. ASL JSON sample is valid and exercises Resource removal (the primary conversion rule)
4. Generated YAML matches converter.py output format (rsf_version injected, Resource removed)
5. Handler stubs explained with @state decorator connection to original Resource field
6. rsf validate confirms the imported workflow passes validation
7. All conversion rules documented in reference section
8. Commands are concrete (`rsf import order-processing.asl.json`, not `rsf import <file>`)
</verification>

<success_criteria>
A user reading this tutorial can: create or use an existing ASL JSON file, run `rsf import` to convert it to RSF YAML, understand the conversion warnings, review the generated handler stubs, and immediately validate and generate from the imported workflow.
</success_criteria>

<output>
After completion, create `.planning/phases/20-advanced-tools/20-01-SUMMARY.md`
</output>
