---
phase: 36-dsl-and-terraform
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/rsf/terraform/generator.py
  - src/rsf/terraform/__init__.py
  - src/rsf/terraform/templates/lambda_url.tf.j2
  - src/rsf/terraform/templates/iam.tf.j2
  - src/rsf/terraform/templates/outputs.tf.j2
  - src/rsf/cli/deploy_cmd.py
  - tests/test_terraform/test_terraform.py
autonomous: true
requirements: [TF-01, TF-02, TF-03]

must_haves:
  truths:
    - "When lambda_url.enabled is true and auth_type is NONE, generated Terraform includes an aws_lambda_function_url resource with authorization_type = NONE"
    - "When lambda_url.enabled is true and auth_type is AWS_IAM, generated Terraform includes an aws_lambda_function_url resource with authorization_type = AWS_IAM"
    - "When lambda_url.enabled is true and auth_type is AWS_IAM, the IAM policy includes a lambda:InvokeFunctionUrl permission statement"
    - "When lambda_url.enabled is true, outputs.tf includes a function_url output with the Lambda Function URL endpoint value"
    - "When lambda_url is not set (None) or enabled is false, no lambda_url.tf file is generated, no extra IAM statement, no extra output"
    - "Existing Terraform generation behavior is unchanged when lambda_url is absent"
  artifacts:
    - path: "src/rsf/terraform/templates/lambda_url.tf.j2"
      provides: "Jinja2 template for aws_lambda_function_url resource"
      contains: "aws_lambda_function_url"
    - path: "src/rsf/terraform/templates/iam.tf.j2"
      provides: "Updated IAM template with conditional InvokeFunctionUrl statement"
      contains: "lambda:InvokeFunctionUrl"
    - path: "src/rsf/terraform/templates/outputs.tf.j2"
      provides: "Updated outputs template with conditional function_url output"
      contains: "function_url"
    - path: "src/rsf/terraform/generator.py"
      provides: "Updated TerraformConfig with lambda_url fields, updated generate_terraform to pass lambda_url context"
      contains: "lambda_url_enabled"
    - path: "tests/test_terraform/test_terraform.py"
      provides: "Tests for lambda_url Terraform generation"
      contains: "TestLambdaUrlTerraform"
  key_links:
    - from: "src/rsf/terraform/generator.py"
      to: "src/rsf/terraform/templates/lambda_url.tf.j2"
      via: "TEMPLATE_FILES dict and render_hcl_template"
      pattern: "lambda_url.tf"
    - from: "src/rsf/cli/deploy_cmd.py"
      to: "src/rsf/terraform/generator.py"
      via: "TerraformConfig with lambda_url fields"
      pattern: "TerraformConfig"
    - from: "src/rsf/terraform/templates/iam.tf.j2"
      to: "src/rsf/terraform/templates/lambda_url.tf.j2"
      via: "Both conditioned on lambda_url_enabled and lambda_url_auth_type"
      pattern: "lambda_url"
---

<objective>
Extend Terraform generation to produce an `aws_lambda_function_url` resource, Lambda URL output, and conditional IAM permissions when the DSL `lambda_url` configuration is enabled. Update the deploy command to pass lambda_url config through to the Terraform generator.

Purpose: This completes Phase 36 — with Plan 01 providing the DSL model, this plan wires it through to actual Terraform infrastructure generation.
Output: New lambda_url.tf.j2 template, updated iam.tf.j2 and outputs.tf.j2, updated generator with lambda_url support, updated deploy command, comprehensive tests.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-dsl-and-terraform/36-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 that this plan depends on. -->

From src/rsf/dsl/types.py (created in Plan 01):
```python
class LambdaUrlAuthType(str, Enum):
    NONE = "NONE"
    AWS_IAM = "AWS_IAM"
```

From src/rsf/dsl/models.py (created in Plan 01):
```python
class LambdaUrlConfig(BaseModel):
    model_config = {"extra": "forbid"}
    enabled: bool
    auth_type: LambdaUrlAuthType

class StateMachineDefinition(BaseModel):
    # ... existing fields ...
    lambda_url: LambdaUrlConfig | None = Field(default=None, alias="lambda_url")
```

From src/rsf/terraform/generator.py (existing — to modify):
```python
TEMPLATE_FILES = {
    "main.tf": "main.tf.j2",
    "variables.tf": "variables.tf.j2",
    "iam.tf": "iam.tf.j2",
    "outputs.tf": "outputs.tf.j2",
    "cloudwatch.tf": "cloudwatch.tf.j2",
    "backend.tf": "backend.tf.j2",
}

@dataclass
class TerraformConfig:
    workflow_name: str
    aws_region: str = "us-east-1"
    name_prefix: str = "rsf"
    backend_bucket: str | None = None
    backend_key: str | None = None
    backend_dynamodb_table: str | None = None

def generate_terraform(config: TerraformConfig, output_dir: Path) -> TerraformResult:
    context = {
        "resource_id": resource_id,
        "workflow_name": config.workflow_name,
        # ... etc
    }
    for filename, template_name in TEMPLATE_FILES.items():
        # renders each template
```

From src/rsf/terraform/engine.py (existing — uses custom Jinja2 delimiters):
```python
# Variables: << var >> instead of {{ var }}
# Blocks: <% if %> instead of {% if %}
# Comments: <# note #> instead of {# note #}
```

From src/rsf/terraform/templates/iam.tf.j2 (existing — 3 IAM statements):
```hcl
# Has CloudWatchLogs, LambdaSelfInvoke, DurableExecution statements
# Resource references use << resource_id >> Jinja2 variable
```

From src/rsf/terraform/templates/outputs.tf.j2 (existing — 4 outputs):
```hcl
# Has function_arn, function_name, role_arn, log_group_name outputs
```

From src/rsf/cli/deploy_cmd.py (existing — creates TerraformConfig):
```python
def _deploy_full(...):
    tf_result = generate_terraform(
        config=TerraformConfig(workflow_name=workflow_name),
        output_dir=tf_dir,
    )
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create lambda_url.tf.j2 template and update iam.tf.j2 / outputs.tf.j2</name>
  <files>src/rsf/terraform/templates/lambda_url.tf.j2, src/rsf/terraform/templates/iam.tf.j2, src/rsf/terraform/templates/outputs.tf.j2, src/rsf/terraform/generator.py, src/rsf/terraform/__init__.py, tests/test_terraform/test_terraform.py</files>
  <behavior>
    - Test: generate_terraform with lambda_url_enabled=True, lambda_url_auth_type="NONE" produces lambda_url.tf containing `aws_lambda_function_url` with `authorization_type = "NONE"`
    - Test: generate_terraform with lambda_url_enabled=True, lambda_url_auth_type="AWS_IAM" produces lambda_url.tf containing `authorization_type = "AWS_IAM"`
    - Test: generate_terraform with lambda_url_enabled=True produces outputs.tf containing `function_url` output
    - Test: generate_terraform with lambda_url_enabled=True, lambda_url_auth_type="AWS_IAM" produces iam.tf with 4 statements (3 base + InvokeFunctionUrl)
    - Test: generate_terraform with lambda_url_enabled=True, lambda_url_auth_type="NONE" produces iam.tf with 3 statements (no InvokeFunctionUrl — NONE auth doesn't need it)
    - Test: generate_terraform with lambda_url_enabled=False produces 6 files (no lambda_url.tf), standard outputs, standard 3 IAM statements
    - Test: generate_terraform with lambda_url_enabled not set (default) produces 6 files (existing behavior preserved)
    - Test: Generated lambda_url.tf has no raw Jinja2 delimiters (<< >> or <% %>)
  </behavior>
  <action>
1. **src/rsf/terraform/generator.py** — Update `TerraformConfig` and `generate_terraform`:
   - Add two fields to `TerraformConfig`:
     ```python
     lambda_url_enabled: bool = False
     lambda_url_auth_type: str = "NONE"
     ```
   - Add `lambda_url.tf.j2` to `TEMPLATE_FILES` dict:
     ```python
     "lambda_url.tf": "lambda_url.tf.j2",
     ```
     This makes it 7 template files total.
   - In `generate_terraform`, add lambda_url fields to the context dict:
     ```python
     "lambda_url_enabled": config.lambda_url_enabled,
     "lambda_url_auth_type": config.lambda_url_auth_type,
     ```
   - Update the generation loop: if `lambda_url_enabled` is `False`, skip rendering `lambda_url.tf`. Add this logic right before `_should_overwrite`:
     ```python
     # Skip lambda_url.tf when not enabled
     if filename == "lambda_url.tf" and not config.lambda_url_enabled:
         continue
     ```

2. **src/rsf/terraform/templates/lambda_url.tf.j2** — Create new template:
   ```hcl
   # DO NOT EDIT - Generated by RSF

   resource "aws_lambda_function_url" "<< resource_id >>_url" {
     function_name      = aws_lambda_function.<< resource_id >>.function_name
     authorization_type = "<< lambda_url_auth_type >>"
   }
   ```
   The entire file is only rendered when `lambda_url_enabled` is true (controlled by the generator loop skip logic), so no Jinja2 conditional block is needed within the template itself.

3. **src/rsf/terraform/templates/iam.tf.j2** — Add conditional 4th IAM statement for InvokeFunctionUrl. Add this block AFTER the existing DurableExecution statement block and BEFORE the closing `]` of the Statement array:
   ```
   <% if lambda_url_enabled and lambda_url_auth_type == "AWS_IAM" %>
   ,
         {
           Sid    = "InvokeFunctionUrl"
           Effect = "Allow"
           Action = [
             "lambda:InvokeFunctionUrl"
           ]
           Resource = aws_lambda_function.<< resource_id >>.arn
         }
   <% endif %>
   ```
   Important: The comma must be placed carefully so the JSON array is valid. Place the comma BEFORE the opening `{` of the new statement, inside the conditional block. Review the existing template to ensure the last existing statement (DurableExecution) does NOT have a trailing comma — the conditional block adds both the comma separator and the new statement.

4. **src/rsf/terraform/templates/outputs.tf.j2** — Add conditional function_url output at the end of the file:
   ```
   <% if lambda_url_enabled %>

   output "function_url" {
     description = "Lambda Function URL endpoint"
     value       = aws_lambda_function_url.<< resource_id >>_url.function_url
   }
   <% endif %>
   ```

5. **src/rsf/terraform/__init__.py** — No changes needed (TerraformConfig is already exported).

6. **tests/test_terraform/test_terraform.py** — Add a new `TestLambdaUrlTerraform` test class at the end of the file with all the behavior tests listed above. Use `TerraformConfig(workflow_name="test", lambda_url_enabled=True, lambda_url_auth_type="NONE")` and similar configurations. For the IAM statement count test, count occurrences of `Sid` in iam.tf content. For the 6-files test (disabled), verify `lambda_url.tf` does NOT exist in the output directory.
  </action>
  <verify>
    <automated>.venv/bin/python -m pytest tests/test_terraform/test_terraform.py::TestLambdaUrlTerraform -xvs 2>&1 | tail -20</automated>
  </verify>
  <done>
  - lambda_url.tf.j2 template exists and renders aws_lambda_function_url resource
  - iam.tf.j2 conditionally includes InvokeFunctionUrl statement when auth_type is AWS_IAM
  - outputs.tf.j2 conditionally includes function_url output when lambda_url is enabled
  - TerraformConfig has lambda_url_enabled and lambda_url_auth_type fields
  - generate_terraform skips lambda_url.tf when not enabled
  - All 8 behavior tests pass
  - All existing Terraform tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire deploy command to pass lambda_url config from DSL to Terraform</name>
  <files>src/rsf/cli/deploy_cmd.py, tests/test_terraform/test_terraform.py</files>
  <action>
1. **src/rsf/cli/deploy_cmd.py** — Update `_deploy_full` to read `lambda_url` from the parsed definition and pass it to `TerraformConfig`:
   - The `definition` variable is already a `StateMachineDefinition` (parsed from YAML via `load_definition`)
   - After Plan 01, `definition.lambda_url` is either `None` or a `LambdaUrlConfig` object
   - Update the `TerraformConfig` construction in `_deploy_full`:
     ```python
     # Build lambda_url config from DSL definition
     lambda_url_enabled = False
     lambda_url_auth_type = "NONE"
     if definition.lambda_url is not None and definition.lambda_url.enabled:
         lambda_url_enabled = True
         lambda_url_auth_type = definition.lambda_url.auth_type.value

     tf_result = generate_terraform(
         config=TerraformConfig(
             workflow_name=workflow_name,
             lambda_url_enabled=lambda_url_enabled,
             lambda_url_auth_type=lambda_url_auth_type,
         ),
         output_dir=tf_dir,
     )
     ```
   - The `definition` parameter type hint in `_deploy_full` is currently `object`. It should remain that way (or be left as-is) to avoid importing unnecessary types. Access `definition.lambda_url` via attribute access — it will work since it's a `StateMachineDefinition` instance at runtime.

2. Run the full test suite to verify no regressions:
   - `pytest tests/test_terraform/ -xvs`
   - `pytest tests/test_cli/ -xvs`
   - `pytest -m "not integration" -q`

Note: The deploy command's `_deploy_code_only` function does not need changes — it only re-packages Lambda code and does not regenerate Terraform.
  </action>
  <verify>
    <automated>.venv/bin/python -m pytest -m "not integration" -q 2>&1 | tail -5</automated>
  </verify>
  <done>
  - deploy_cmd.py reads lambda_url from parsed definition and passes to TerraformConfig
  - When user has lambda_url in their workflow YAML, `rsf deploy` generates Terraform with the Lambda URL resource
  - When user omits lambda_url, deploy behavior is unchanged
  - All tests pass with zero failures
  - `ruff check .` reports zero violations
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_terraform/test_terraform.py -v` — all Terraform tests pass (existing + new lambda_url tests)
2. `pytest tests/test_cli/ -v` — all CLI tests pass
3. `pytest -m "not integration" -q` — full non-integration suite passes (744+ tests, 0 failures)
4. `ruff check .` — zero lint violations
5. Manual verification: Generate Terraform with lambda_url enabled and inspect the output files:
   ```python
   from rsf.terraform.generator import TerraformConfig, generate_terraform
   from pathlib import Path
   import tempfile
   d = Path(tempfile.mkdtemp())
   generate_terraform(TerraformConfig(workflow_name="test", lambda_url_enabled=True, lambda_url_auth_type="AWS_IAM"), d)
   print((d / "lambda_url.tf").read_text())
   print((d / "iam.tf").read_text())
   print((d / "outputs.tf").read_text())
   ```
</verification>

<success_criteria>
- When lambda_url is enabled with auth_type NONE, Terraform includes aws_lambda_function_url with authorization_type NONE
- When lambda_url is enabled with auth_type AWS_IAM, Terraform includes aws_lambda_function_url with authorization_type AWS_IAM and IAM includes lambda:InvokeFunctionUrl
- outputs.tf includes function_url output when lambda_url is enabled
- When lambda_url is not set or disabled, Terraform generation is identical to before (no lambda_url.tf, no extra IAM, no extra output)
- deploy command wires DSL lambda_url config to Terraform generation
- All tests pass, no regressions, no lint violations
</success_criteria>

<output>
After completion, create `.planning/phases/36-dsl-and-terraform/36-02-SUMMARY.md`
</output>
