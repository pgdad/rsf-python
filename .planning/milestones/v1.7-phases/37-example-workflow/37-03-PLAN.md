---
phase: 37-example-workflow
plan: 03
type: execute
wave: 2
depends_on: [37-01]
files_modified:
  - examples/lambda-url-trigger/terraform/main.tf
  - examples/lambda-url-trigger/terraform/variables.tf
  - examples/lambda-url-trigger/terraform/outputs.tf
  - examples/lambda-url-trigger/terraform/iam.tf
  - examples/lambda-url-trigger/terraform/backend.tf
  - examples/lambda-url-trigger/terraform/versions.tf
  - examples/lambda-url-trigger/terraform/cloudwatch.tf
  - examples/lambda-url-trigger/terraform/lambda_url.tf
  - examples/lambda-url-trigger/terraform/terraform.tfvars
  - examples/lambda-url-trigger/src/generated/__init__.py
  - examples/lambda-url-trigger/src/generated/orchestrator.py
  - examples/lambda-url-trigger/src/handlers/__init__.py
  - examples/lambda-url-trigger/src/handlers/validate_order.py
  - examples/lambda-url-trigger/src/handlers/process_order.py
  - tests/test_examples/test_lambda_url_trigger.py
autonomous: true
requirements: [EX-01, EX-03]
must_haves:
  truths:
    - "Terraform directory exists with lambda_url.tf for the Function URL resource"
    - "Generated Terraform outputs include the function_url endpoint"
    - "Integration test POSTs to the Lambda URL and verifies execution completes"
    - "Integration test is marked with @pytest.mark.integration"
  artifacts:
    - path: "examples/lambda-url-trigger/terraform/main.tf"
      provides: "Lambda function resource"
      contains: "aws_lambda_function"
    - path: "examples/lambda-url-trigger/terraform/lambda_url.tf"
      provides: "Lambda Function URL resource"
      contains: "aws_lambda_function_url"
    - path: "examples/lambda-url-trigger/terraform/outputs.tf"
      provides: "Terraform outputs including function_url"
      contains: "function_url"
    - path: "tests/test_examples/test_lambda_url_trigger.py"
      provides: "Integration test for Lambda URL invocation"
      contains: "pytest.mark.integration"
  key_links:
    - from: "tests/test_examples/test_lambda_url_trigger.py"
      to: "examples/lambda-url-trigger/terraform/"
      via: "terraform_deploy"
      pattern: "terraform_deploy"
    - from: "tests/test_examples/test_lambda_url_trigger.py"
      to: "Lambda Function URL"
      via: "HTTP POST with requests library"
      pattern: "requests.post"
---

<objective>
Create Terraform infrastructure, generated orchestrator code, and an integration test that deploys to AWS, POSTs to the Lambda Function URL, and verifies execution.

Purpose: Complete the example with deployable infrastructure (EX-01) and an integration test (EX-03) that proves the Lambda URL trigger works end-to-end on real AWS.

Output: examples/lambda-url-trigger/terraform/, src/, and tests/test_examples/test_lambda_url_trigger.py
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-example-workflow/37-01-SUMMARY.md
@examples/order-processing/terraform/main.tf
@examples/order-processing/terraform/variables.tf
@examples/order-processing/terraform/outputs.tf
@examples/order-processing/terraform/iam.tf
@examples/order-processing/terraform/backend.tf
@examples/order-processing/terraform/versions.tf
@examples/order-processing/terraform/cloudwatch.tf
@examples/order-processing/terraform/terraform.tfvars
@examples/order-processing/src/generated/orchestrator.py
@src/rsf/terraform/templates/lambda_url.tf.j2
@src/rsf/terraform/templates/outputs.tf.j2
@tests/test_examples/conftest.py
@tests/test_examples/test_order_processing.py
</context>

<interfaces>
<!-- Key types and contracts the executor needs -->

From src/rsf/terraform/templates/lambda_url.tf.j2:
```hcl
resource "aws_lambda_function_url" "<resource_id>_url" {
  function_name      = aws_lambda_function.<resource_id>.function_name
  authorization_type = "<lambda_url_auth_type>"
}
```

From src/rsf/terraform/templates/outputs.tf.j2 (when lambda_url_enabled):
```hcl
output "function_url" {
  description = "Lambda Function URL endpoint"
  value       = aws_lambda_function_url.<resource_id>_url.function_url
}
```

From tests/test_examples/conftest.py:
```python
def terraform_deploy(example_dir: Path) -> dict[str, str]  # Returns outputs dict
def terraform_teardown(example_dir, logs_client, log_group_name)
def poll_execution(lambda_client, function_name, execution_name, timeout, poll_interval) -> dict
def make_execution_id(name: str) -> str
def iam_propagation_wait(seconds: float = 15.0)

# Fixtures: lambda_client, logs_client, aws_region
```

From rsf.codegen.generator:
```python
def generate(definition: StateMachineDefinition, dsl_path: Path) -> str  # Returns orchestrator code
def render_orchestrator(definition, mappings, dsl_path) -> str
```

From rsf.terraform.generator:
```python
def generate_terraform(config: TerraformConfig, output_dir: Path) -> TerraformResult
class TerraformConfig:
    lambda_url_enabled: bool = False
    lambda_url_auth_type: str = "NONE"
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Generate Terraform and orchestrator code using rsf CLI</name>
  <files>
    examples/lambda-url-trigger/terraform/main.tf
    examples/lambda-url-trigger/terraform/variables.tf
    examples/lambda-url-trigger/terraform/outputs.tf
    examples/lambda-url-trigger/terraform/iam.tf
    examples/lambda-url-trigger/terraform/backend.tf
    examples/lambda-url-trigger/terraform/versions.tf
    examples/lambda-url-trigger/terraform/cloudwatch.tf
    examples/lambda-url-trigger/terraform/lambda_url.tf
    examples/lambda-url-trigger/terraform/terraform.tfvars
    examples/lambda-url-trigger/src/generated/__init__.py
    examples/lambda-url-trigger/src/generated/orchestrator.py
    examples/lambda-url-trigger/src/handlers/__init__.py
    examples/lambda-url-trigger/src/handlers/validate_order.py
    examples/lambda-url-trigger/src/handlers/process_order.py
  </files>
  <action>
Use the RSF CLI to generate Terraform and orchestrator code for the lambda-url-trigger example. The preferred approach is to use `rsf generate` if available, or programmatically call the generators.

**Step 1: Generate orchestrator code**
Use `rsf.codegen.generator` to generate orchestrator.py from workflow.yaml:
```python
from rsf.dsl.parser import load_definition
from rsf.codegen.generator import generate
from pathlib import Path

dsl_path = Path("examples/lambda-url-trigger/workflow.yaml")
definition = load_definition(dsl_path)
code = generate(definition, dsl_path)
# Write to examples/lambda-url-trigger/src/generated/orchestrator.py
```

Also create `src/generated/__init__.py` (empty) and copy handlers into `src/handlers/` (these go in the Lambda deployment package). The `src/handlers/` copies should NOT have the `@state` decorator import — they are plain modules imported by the orchestrator.

**Step 2: Generate Terraform files**
Use `rsf.terraform.generator` to generate Terraform with lambda_url enabled:
```python
from rsf.terraform.generator import generate_terraform, TerraformConfig

config = TerraformConfig(
    workflow_name="lambda-url-trigger",
    lambda_url_enabled=True,
    lambda_url_auth_type="NONE",
)
generate_terraform(config, output_dir=Path("examples/lambda-url-trigger/terraform"))
```

**Step 3: Create terraform.tfvars**
Follow the pattern from order-processing:
```hcl
workflow_name = "lambda-url-trigger"
```

**Step 4: Verify lambda_url.tf exists**
Confirm the generated Terraform includes:
- `lambda_url.tf` with `aws_lambda_function_url` resource
- `outputs.tf` with `function_url` output
- `iam.tf` with standard permissions

Note: If `rsf generate` CLI command handles all of this in one shot, use that instead of programmatic calls. Check `rsf generate --help` or `rsf --help` first.
  </action>
  <verify>
    <automated>test -f /home/esa/git/rsf-python/examples/lambda-url-trigger/terraform/lambda_url.tf && grep -q "aws_lambda_function_url" /home/esa/git/rsf-python/examples/lambda-url-trigger/terraform/lambda_url.tf && grep -q "function_url" /home/esa/git/rsf-python/examples/lambda-url-trigger/terraform/outputs.tf && echo "OK"</automated>
  </verify>
  <done>
    - terraform/ directory contains all HCL files including lambda_url.tf
    - lambda_url.tf has aws_lambda_function_url resource with authorization_type = "NONE"
    - outputs.tf includes function_url output
    - src/generated/orchestrator.py exists with generated code
    - src/handlers/ contains handler modules for Lambda deployment package
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test</name>
  <files>tests/test_examples/test_lambda_url_trigger.py</files>
  <action>
Create the integration test following the established pattern from `tests/test_examples/test_order_processing.py`.

**tests/test_examples/test_lambda_url_trigger.py:**

```python
"""Integration tests for the lambda-url-trigger example.

Deploys to real AWS, POSTs to the Lambda Function URL, and verifies:
- Lambda Function URL is accessible [EX-03]
- HTTP POST triggers a durable execution [EX-03]
- Execution completes with SUCCEEDED status [EX-03]
"""
```

Key design decisions from CONTEXT.md (locked):
- POST to the Lambda Function URL, then poll Step Functions until execution completes
- Verify final output matches expected processed order result
- Mark with `@pytest.mark.integration`

**Test class: TestLambdaUrlTriggerIntegration**

`deployment` fixture (class-scoped):
1. `terraform_deploy(EXAMPLE_DIR)` — deploy infrastructure
2. `iam_propagation_wait()` — wait for IAM propagation
3. Extract `function_url` from terraform outputs (this is the Lambda URL endpoint)
4. POST to the function_url using `requests.post(url, json=ORDER_EVENT)`
5. The Lambda URL triggers the durable execution asynchronously
6. Poll for execution completion using `poll_execution()`
7. Yield the context dict with execution, outputs, etc.
8. In teardown: `terraform_teardown()`

Test event:
```python
ORDER_EVENT = {
    "orderId": "test-url-001",
    "items": [{"name": "Widget", "price": 29.99, "quantity": 2}],
    "total": 59.98,
}
```

Tests:
- `test_execution_succeeded` — assert execution status is "SUCCEEDED"
- `test_function_url_exists` — assert "function_url" in terraform outputs
- `test_function_url_is_https` — assert the URL starts with "https://"

Note: The integration test uses `requests` library to POST to the Lambda URL. This is different from the other integration tests that use `lambda_client.invoke()` — the whole point of this example is demonstrating HTTP invocation.

Important: The Lambda Function URL returns a response immediately (it's async invocation under the hood for durable executions). The test should POST, then poll for execution completion separately using the lambda_client.

For polling: After POST, use `poll_execution(lambda_client, function_name, execution_name)`. The execution_name may need to be extracted from the POST response or generated beforehand.

Alternative approach if Lambda URL + durable execution uses synchronous invocation: POST returns the execution result directly. Check the response status code and body.
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -c "import ast; ast.parse(open('tests/test_examples/test_lambda_url_trigger.py').read()); print('Syntax OK')" && grep -q "pytest.mark.integration" tests/test_examples/test_lambda_url_trigger.py && echo "OK"</automated>
  </verify>
  <done>
    - test_lambda_url_trigger.py exists with @pytest.mark.integration marker
    - Test uses requests.post() to invoke via Lambda Function URL
    - Test polls for execution completion and verifies SUCCEEDED status
    - Test follows the established pattern from other integration test files
    - Test is NOT discovered by `pytest -m "not integration"` (excluded by marker)
  </done>
</task>

</tasks>

<verification>
1. `ls examples/lambda-url-trigger/terraform/lambda_url.tf` — file exists
2. `grep "function_url" examples/lambda-url-trigger/terraform/outputs.tf` — output present
3. `grep "pytest.mark.integration" tests/test_examples/test_lambda_url_trigger.py` — marker present
4. `python -m pytest -m "not integration" --co -q 2>&1 | grep -c "test_lambda_url_trigger"` — returns 0 (excluded)
5. `python -c "import ast; ast.parse(open('tests/test_examples/test_lambda_url_trigger.py').read())"` — syntax valid
</verification>

<success_criteria>
- Terraform directory includes lambda_url.tf with Function URL resource
- outputs.tf includes function_url output value
- Integration test uses requests.post() to invoke via Lambda URL
- Integration test is marked with @pytest.mark.integration
- Integration test follows established patterns (terraform_deploy, poll_execution, teardown)
- src/ directory contains generated orchestrator and handler copies for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/37-example-workflow/37-03-SUMMARY.md`
</output>
