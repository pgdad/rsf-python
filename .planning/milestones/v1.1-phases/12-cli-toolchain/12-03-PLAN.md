---
phase: 12-cli-toolchain
plan: 03
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/rsf/cli/deploy_cmd.py
  - src/rsf/cli/main.py
  - tests/test_cli/test_deploy.py
autonomous: true
requirements:
  - CLI-04

must_haves:
  truths:
    - "Running `rsf deploy` in a project directory generates Terraform files and runs terraform init + apply"
    - "Running `rsf deploy --code-only` re-packages Lambda code and updates it without running full Terraform apply"
    - "Running `rsf deploy` with no workflow.yaml in the directory prints an error and exits 1"
    - "Running `rsf deploy` when terraform binary is not found prints a clear error"
  artifacts:
    - path: "src/rsf/cli/deploy_cmd.py"
      provides: "rsf deploy subcommand with --code-only flag"
      contains: "def deploy"
    - path: "tests/test_cli/test_deploy.py"
      provides: "Tests for deploy subcommand"
      min_lines: 40
  key_links:
    - from: "src/rsf/cli/deploy_cmd.py"
      to: "src/rsf/terraform/generator.py"
      via: "generate_terraform() for HCL file creation"
      pattern: "from rsf.terraform.generator import"
    - from: "src/rsf/cli/deploy_cmd.py"
      to: "src/rsf/codegen/generator.py"
      via: "generate() for code-only repackaging"
      pattern: "from rsf.codegen.generator import generate"
    - from: "src/rsf/cli/deploy_cmd.py"
      to: "subprocess"
      via: "terraform init/apply execution"
      pattern: "subprocess.run.*terraform"
---

<objective>
Implement the `rsf deploy` subcommand that generates Terraform, runs `terraform init/apply`, and supports `--code-only` for Lambda code-only updates.

Purpose: Let users deploy their RSF workflows to AWS directly from the terminal with a single command.

Output: `src/rsf/cli/deploy_cmd.py`, tests.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cli-toolchain/12-01-SUMMARY.md
@src/rsf/terraform/generator.py
@src/rsf/codegen/generator.py
@src/rsf/dsl/parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rsf deploy subcommand with Terraform and code-only modes</name>
  <files>
    src/rsf/cli/deploy_cmd.py
    src/rsf/cli/main.py
    tests/test_cli/test_deploy.py
  </files>
  <action>
    Create `src/rsf/cli/deploy_cmd.py`:

    **Signature:**
    ```
    def deploy(
        workflow: Path = typer.Argument("workflow.yaml", help="Path to workflow YAML file"),
        code_only: bool = typer.Option(False, "--code-only", help="Re-package and update Lambda code only"),
        auto_approve: bool = typer.Option(False, "--auto-approve", "-y", help="Skip Terraform confirmation prompt"),
        tf_dir: Path = typer.Option("terraform", "--tf-dir", help="Terraform output directory"),
    )
    ```

    **Full deploy flow (default):**
    1. Check workflow file exists; error and exit 1 if not
    2. Load and validate the workflow (load_definition + validate_definition); exit 1 on errors
    3. Generate orchestrator + handlers via `rsf.codegen.generator.generate()` — print summary
    4. Extract workflow name from the definition (use `definition.comment` or derive from filename)
    5. Generate Terraform files via `rsf.terraform.generator.generate_terraform(TerraformConfig(workflow_name=name), output_dir=tf_dir)` — print summary
    6. Check `terraform` binary exists in PATH using `shutil.which("terraform")` — if not, print `[red]Error:[/red] terraform binary not found. Install from https://terraform.io` and exit 1
    7. Run `subprocess.run(["terraform", "init"], cwd=tf_dir, check=True)` — stream stdout/stderr
    8. Build the apply command: `["terraform", "apply"]` — append `-auto-approve` if `auto_approve` is True
    9. Run `subprocess.run(apply_cmd, cwd=tf_dir, check=True)` — stream stdout/stderr
    10. Catch `subprocess.CalledProcessError` — print error, exit 1
    11. Print `[green]Deploy complete[/green]` on success

    **Code-only flow (--code-only):**
    1. Check workflow file exists
    2. Load and validate the workflow
    3. Re-generate orchestrator + handlers (Generation Gap preserves existing handlers)
    4. Check `terraform` binary exists; check tf_dir exists with terraform state
    5. Run `subprocess.run(["terraform", "apply", "-target=aws_lambda_function.*", "-auto-approve"], cwd=tf_dir, check=True)` to update only the Lambda resource
    6. Print `[green]Code update complete[/green]`

    Use `rich.console.Console()` for all output. Use `rich.status.Status` or `rich.progress` for "Generating..." / "Deploying..." spinners.

    Register in `main.py`.

    **Tests** in `tests/test_cli/test_deploy.py`:
    - Use `CliRunner`, `tmp_path`, and `monkeypatch`
    - Mock `shutil.which` to control terraform availability
    - Mock `subprocess.run` to prevent actual terraform execution — verify it's called with correct args
    - Test: `rsf deploy` with valid workflow and mocked terraform → exit 0, subprocess called with `["terraform", "init"]` then `["terraform", "apply"]`
    - Test: `rsf deploy --code-only` → subprocess called with `-target` flag
    - Test: `rsf deploy --auto-approve` → subprocess called with `-auto-approve`
    - Test: No workflow.yaml → exit 1
    - Test: terraform not in PATH → exit 1, error message mentions terraform
    - Test: subprocess.CalledProcessError → exit 1 with error
    - Do NOT actually run terraform in tests — all subprocess calls must be mocked
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_deploy.py -x -v</automated>
  </verify>
  <done>
    `rsf deploy` generates Terraform and runs terraform init/apply with proper error handling. `rsf deploy --code-only` targets only Lambda code update. terraform binary detection works. All subprocess calls are mocked in tests. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_cli/test_deploy.py -x -v` — all tests pass
2. No actual terraform or AWS calls made during tests (all mocked)
3. `rsf deploy --help` shows all options including --code-only, --auto-approve, --tf-dir
</verification>

<success_criteria>
- `rsf deploy` orchestrates full pipeline: validate → codegen → terraform gen → terraform init → terraform apply
- `rsf deploy --code-only` skips full Terraform apply, targets Lambda resource only
- terraform binary absence produces a clear error message
- All tests pass with mocked subprocess
</success_criteria>

<output>
After completion, create `.planning/phases/12-cli-toolchain/12-03-SUMMARY.md`
</output>
