---
phase: 12-cli-toolchain
plan: 02
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/rsf/cli/generate_cmd.py
  - src/rsf/cli/validate_cmd.py
  - src/rsf/cli/main.py
  - tests/test_cli/test_generate.py
  - tests/test_cli/test_validate.py
autonomous: true
requirements:
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "Running `rsf generate workflow.yaml` produces an orchestrator.py and handler stubs"
    - "Running `rsf generate` with no argument defaults to workflow.yaml in the current directory"
    - "Running `rsf validate workflow.yaml` on a valid file prints success message with exit code 0"
    - "Running `rsf validate workflow.yaml` on a broken file prints field-path-specific errors with exit code 1"
    - "Running `rsf validate` does NOT generate any code"
  artifacts:
    - path: "src/rsf/cli/generate_cmd.py"
      provides: "rsf generate subcommand"
      contains: "def generate"
    - path: "src/rsf/cli/validate_cmd.py"
      provides: "rsf validate subcommand"
      contains: "def validate"
    - path: "tests/test_cli/test_generate.py"
      provides: "Tests for generate subcommand"
      min_lines: 30
    - path: "tests/test_cli/test_validate.py"
      provides: "Tests for validate subcommand"
      min_lines: 30
  key_links:
    - from: "src/rsf/cli/generate_cmd.py"
      to: "src/rsf/codegen/generator.py"
      via: "generate() function call"
      pattern: "from rsf.codegen.generator import generate"
    - from: "src/rsf/cli/generate_cmd.py"
      to: "src/rsf/dsl/parser.py"
      via: "load_definition() for parsing"
      pattern: "from rsf.dsl.parser import load_definition"
    - from: "src/rsf/cli/validate_cmd.py"
      to: "src/rsf/dsl/validator.py"
      via: "validate_definition() for semantic validation"
      pattern: "from rsf.dsl.validator import validate_definition"
    - from: "src/rsf/cli/validate_cmd.py"
      to: "src/rsf/dsl/parser.py"
      via: "load_yaml + parse_definition for Pydantic validation"
      pattern: "from rsf.dsl.parser import"
---

<objective>
Implement the `rsf generate` and `rsf validate` subcommands that wire the existing DSL parser, validator, and code generator into CLI commands.

Purpose: Let users generate orchestrator code and validate workflows from the terminal without writing Python scripts.

Output: `src/rsf/cli/generate_cmd.py`, `src/rsf/cli/validate_cmd.py`, tests.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cli-toolchain/12-01-SUMMARY.md
@src/rsf/dsl/parser.py
@src/rsf/dsl/validator.py
@src/rsf/codegen/generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rsf validate subcommand with field-path error reporting</name>
  <files>
    src/rsf/cli/validate_cmd.py
    src/rsf/cli/main.py
    tests/test_cli/test_validate.py
  </files>
  <action>
    Create `src/rsf/cli/validate_cmd.py`:

    **Signature:**
    ```
    def validate(
        workflow: Path = typer.Argument("workflow.yaml", help="Path to workflow YAML file"),
    )
    ```

    **Behavior:**
    1. Check that the workflow file exists; if not, print `[red]Error:[/red] File not found: {workflow}` and exit 1
    2. Try to load with `rsf.dsl.parser.load_yaml(workflow)` — catch YAML parse errors, print user-friendly message, exit 1
    3. Try to parse with `rsf.dsl.parser.parse_definition(data)` — catch `pydantic.ValidationError`, format each error with field path: `{'.'.join(err['loc'])}: {err['msg']}`, exit 1
    4. Run semantic validation with `rsf.dsl.validator.validate_definition(definition)` — if errors returned, format each with field path prefix from the `ValidationError.path` field, exit 1
    5. If all pass, print `[green]Valid:[/green] {workflow}` and exit 0

    Use `rich.console.Console()` for styled output. Do NOT import or call any codegen — validate is validation-only.

    Register in `main.py`.

    **Tests** in `tests/test_cli/test_validate.py`:
    - Use `CliRunner` and `tmp_path` with fixture workflow files
    - Test: valid workflow.yaml → exit 0, output contains "Valid"
    - Test: file not found → exit 1, output contains "not found"
    - Test: malformed YAML (bad indentation) → exit 1
    - Test: invalid DSL (missing StartAt) → exit 1, output contains field path
    - Test: semantically invalid (dangling Next reference) → exit 1, output contains the bad state name
    - Use a fixture from `fixtures/` directory if available, or create inline YAML strings written to tmp_path
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_validate.py -x -v</automated>
  </verify>
  <done>
    `rsf validate workflow.yaml` on valid file prints "Valid" with exit 0. On broken file, prints field-path errors with exit 1. No code generation occurs. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rsf generate subcommand with orchestrator and handler output</name>
  <files>
    src/rsf/cli/generate_cmd.py
    src/rsf/cli/main.py
    tests/test_cli/test_generate.py
  </files>
  <action>
    Create `src/rsf/cli/generate_cmd.py`:

    **Signature:**
    ```
    def generate(
        workflow: Path = typer.Argument("workflow.yaml", help="Path to workflow YAML file"),
        output_dir: Path = typer.Option(".", "--output", "-o", help="Output directory"),
    )
    ```

    **Behavior:**
    1. Check workflow file exists; if not, error and exit 1
    2. Load and parse: `rsf.dsl.parser.load_definition(workflow)` — catch Pydantic ValidationError, format errors (reuse pattern from validate), exit 1
    3. Run semantic validation: `rsf.dsl.validator.validate_definition(definition)` — if errors, print them, exit 1
    4. Call `rsf.codegen.generator.generate(definition, dsl_path=workflow, output_dir=output_dir, handlers_dir=output_dir / "handlers")` with `rsf_version` from `rsf.__version__`
    5. Print summary: orchestrator path created, number of handlers created, number of handlers skipped (already exist)
    6. Use Rich console for styled output with green checkmarks for created files, yellow for skipped

    Register in `main.py`.

    **Tests** in `tests/test_cli/test_generate.py`:
    - Use `CliRunner` and `tmp_path`
    - Create a valid workflow.yaml in tmp_path (with at least one Task state and one terminal state)
    - Test: `rsf generate workflow.yaml` creates orchestrator.py and handler stubs
    - Test: Running generate twice skips existing handler stubs (Generation Gap)
    - Test: Invalid workflow.yaml → exit 1 with error message, no files created
    - Test: File not found → exit 1
    - Test: Default argument (workflow.yaml in current dir when no arg given)
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_generate.py -x -v</automated>
  </verify>
  <done>
    `rsf generate workflow.yaml` parses, validates, and generates orchestrator + handler stubs. Invalid input produces clear errors with exit 1. Generation Gap preserves existing handlers. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_cli/test_validate.py tests/test_cli/test_generate.py -x -v` — all tests pass
2. `rsf validate` on valid fixture produces exit 0
3. `rsf validate` on invalid fixture produces field-path errors with exit 1
4. `rsf generate` on valid fixture creates orchestrator.py and handler stubs
5. `rsf validate` does not create any files (ls before/after matches)
</verification>

<success_criteria>
- `rsf validate` validates without generating code, prints field-path errors on failure
- `rsf generate` validates then generates orchestrator + handlers with Rich summary
- Both commands default to `workflow.yaml` when no file argument given
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-cli-toolchain/12-02-SUMMARY.md`
</output>
