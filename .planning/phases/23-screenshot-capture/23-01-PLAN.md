---
phase: 23-screenshot-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/scripts/capture-screenshots.ts
  - ui/package.json
  - docs/images/order-processing-graph.png
  - docs/images/order-processing-dsl.png
  - docs/images/order-processing-inspector.png
  - docs/images/approval-workflow-graph.png
  - docs/images/approval-workflow-dsl.png
  - docs/images/approval-workflow-inspector.png
  - docs/images/data-pipeline-graph.png
  - docs/images/data-pipeline-dsl.png
  - docs/images/data-pipeline-inspector.png
  - docs/images/retry-and-recovery-graph.png
  - docs/images/retry-and-recovery-dsl.png
  - docs/images/retry-and-recovery-inspector.png
  - docs/images/intrinsic-showcase-graph.png
  - docs/images/intrinsic-showcase-dsl.png
  - docs/images/intrinsic-showcase-inspector.png
autonomous: true
requirements: [CAPT-04, CAPT-05, CAPT-06, CAPT-07]

must_haves:
  truths:
    - "Running `npm run screenshots` in ui/ generates all 15 PNG files in docs/images/ without manual intervention"
    - "Graph editor full-layout screenshots show the complete workflow graph with all nodes and edges visible for each example"
    - "Graph editor DSL-editing screenshots show the YAML editor panel alongside the graph for each example"
    - "Execution inspector screenshots show a populated inspector view with state timeline and event data for each example"
    - "Re-running the script overwrites existing files and completes without error"
  artifacts:
    - path: "ui/scripts/capture-screenshots.ts"
      provides: "Playwright screenshot capture orchestrator"
      min_lines: 150
    - path: "docs/images/order-processing-graph.png"
      provides: "Graph editor full-layout screenshot for order-processing"
    - path: "docs/images/order-processing-dsl.png"
      provides: "Graph editor DSL-editing screenshot for order-processing"
    - path: "docs/images/order-processing-inspector.png"
      provides: "Inspector screenshot for order-processing"
    - path: "docs/images/approval-workflow-graph.png"
      provides: "Graph editor full-layout screenshot for approval-workflow"
    - path: "docs/images/approval-workflow-dsl.png"
      provides: "Graph editor DSL-editing screenshot for approval-workflow"
    - path: "docs/images/approval-workflow-inspector.png"
      provides: "Inspector screenshot for approval-workflow"
    - path: "docs/images/data-pipeline-graph.png"
      provides: "Graph editor full-layout screenshot for data-pipeline"
    - path: "docs/images/data-pipeline-dsl.png"
      provides: "Graph editor DSL-editing screenshot for data-pipeline"
    - path: "docs/images/data-pipeline-inspector.png"
      provides: "Inspector screenshot for data-pipeline"
    - path: "docs/images/retry-and-recovery-graph.png"
      provides: "Graph editor full-layout screenshot for retry-and-recovery"
    - path: "docs/images/retry-and-recovery-dsl.png"
      provides: "Graph editor DSL-editing screenshot for retry-and-recovery"
    - path: "docs/images/retry-and-recovery-inspector.png"
      provides: "Inspector screenshot for retry-and-recovery"
    - path: "docs/images/intrinsic-showcase-graph.png"
      provides: "Graph editor full-layout screenshot for intrinsic-showcase"
    - path: "docs/images/intrinsic-showcase-dsl.png"
      provides: "Graph editor DSL-editing screenshot for intrinsic-showcase"
    - path: "docs/images/intrinsic-showcase-inspector.png"
      provides: "Inspector screenshot for intrinsic-showcase"
  key_links:
    - from: "ui/scripts/capture-screenshots.ts"
      to: "ui/scripts/start-ui-server.ts"
      via: "child_process.spawn for graph editor server lifecycle"
      pattern: "spawn.*start-ui-server"
    - from: "ui/scripts/capture-screenshots.ts"
      to: "ui/scripts/start-inspect-server.ts"
      via: "child_process.spawn for mock inspect server lifecycle"
      pattern: "spawn.*start-inspect-server"
    - from: "ui/scripts/capture-screenshots.ts"
      to: "docs/images/"
      via: "page.screenshot() saving PNG files"
      pattern: "screenshot.*docs/images"
    - from: "ui/package.json"
      to: "ui/scripts/capture-screenshots.ts"
      via: "npm run screenshots script entry"
      pattern: "screenshots.*capture-screenshots"
---

<objective>
Capture all 15 screenshots (graph editor full layout, graph editor DSL view, and execution inspector for each of 5 examples) as PNG files in docs/images/ via a Playwright-based capture script, and wire up a single `npm run screenshots` command.

Purpose: Provides visual documentation assets showing the graph editor and execution inspector for all example workflows, enabling documentation integration in Phase 24.
Output: 15 PNG screenshots in docs/images/, capture-screenshots.ts script, npm script entry
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-mock-fixtures-and-server-automation/22-01-SUMMARY.md
@.planning/phases/22-mock-fixtures-and-server-automation/22-02-SUMMARY.md

<interfaces>
<!-- Key interfaces the executor needs. Extracted from codebase. -->

From ui/scripts/start-ui-server.ts:
- CLI: `node --import tsx/esm scripts/start-ui-server.ts --example <name> --port <port>`
- Stdout signals: `SERVER_READY: http://127.0.0.1:{port}` and `SERVER_STOPPED`
- Serves graph editor SPA + WebSocket + API on the given port
- Default port: 8765

From ui/scripts/start-inspect-server.ts:
- CLI: `node --import tsx/esm scripts/start-inspect-server.ts --example <name> --port <port>`
- Stdout signals: `SERVER_READY: http://127.0.0.1:{port}` and `SERVER_STOPPED`
- Spawns mock-inspect-server.ts underneath
- Default port: 8766

From ui/vite.config.ts:
- Vite dev server proxies:
  - `/ws` -> ws://127.0.0.1:8765
  - `/api/inspect` -> http://127.0.0.1:8766
  - `/api` -> http://127.0.0.1:8765
- Dev server default port: 5173

From ui/src/App.tsx:
- Hash routes: `#/editor` (default) for graph editor, `#/inspector` for inspector
- Graph editor layout: `.app > .app-header + .app-body` where `.app-body` = Palette + MonacoEditor + GraphCanvas
- Editor pane class: `.editor-pane` (width: 400px)
- Graph pane class: `.graph-pane` (flex: 1)

From ui/src/inspector/InspectorApp.tsx:
- Inspector layout: `.app > .app-header + .inspector-body`
- `.inspector-body` = `.inspector-left` (ExecutionList, 280px) + `.inspector-center` (InspectorGraph + TimelineScrubber) + `.inspector-right` (EventTimeline + StateDetailPanel, 320px)

From ui/src/inspector/ExecutionList.tsx:
- Auto-fetches executions on mount from `/api/inspect/executions`
- Click `.execution-list-item` to select and stream execution detail via SSE

From ui/src/inspector/useSSE.ts:
- Connects to `/api/inspect/execution/{id}/stream` via EventSource
- Receives `execution_info` and `history` events
- Auto-closes on terminal status (SUCCEEDED)

From ui/scripts/smoke-test.ts:
- Pattern for Playwright usage: `import { chromium } from '@playwright/test'`
- Browser launch: `chromium.launch({ headless: true })`

From ui/src/components/GraphCanvas.tsx:
- Uses `@xyflow/react` ReactFlow component
- Graph renders in `.graph-pane` with `.react-flow` container

Naming convention for output files:
- `docs/images/{example-name}-graph.png` — graph editor full layout
- `docs/images/{example-name}-dsl.png` — graph editor DSL editing view
- `docs/images/{example-name}-inspector.png` — execution inspector

5 examples: order-processing, approval-workflow, data-pipeline, retry-and-recovery, intrinsic-showcase
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create capture-screenshots.ts Playwright capture script</name>
  <files>ui/scripts/capture-screenshots.ts, docs/images/</files>
  <action>
Create `ui/scripts/capture-screenshots.ts` — the main screenshot orchestration script using Playwright and the server lifecycle scripts from Phase 22.

**Architecture:**

The script captures 15 screenshots (3 per example x 5 examples) by:
1. Launching a Chromium browser once
2. For each example workflow sequentially:
   a. Start rsf ui server (for graph editor screenshots)
   b. Navigate to rsf ui URL, wait for graph to render, capture full-layout and DSL screenshots
   c. Stop rsf ui server
   d. Start Vite dev server + mock inspect server (for inspector screenshots)
   e. Navigate to Vite URL with `#/inspector`, wait for execution list to load, click first execution, wait for inspector graph + timeline to populate, capture inspector screenshot
   f. Stop Vite dev server + mock inspect server
3. Close browser

**Server management approach:**

Rather than using start-ui-server.ts and start-inspect-server.ts as child processes (which would be processes-spawning-processes), implement the server lifecycle inline using the same pattern:
- For rsf ui: spawn the rsf binary directly (same venv detection as start-ui-server.ts)
- For mock inspect: spawn `node --import tsx/esm scripts/mock-inspect-server.ts`
- For Vite dev: spawn `npx vite --port <port>` in the ui/ directory
- Poll health-check endpoints to confirm readiness
- SIGTERM + SIGKILL fallback for cleanup

**Key implementation details:**

```typescript
import { chromium } from '@playwright/test';
import { spawn, execFileSync, type ChildProcess } from 'node:child_process';
import { existsSync, mkdirSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
```

Constants:
```typescript
const EXAMPLES = ['order-processing', 'approval-workflow', 'data-pipeline', 'retry-and-recovery', 'intrinsic-showcase'];
const UI_PORT = 8765;
const INSPECT_PORT = 8766;
const VITE_PORT = 5199;  // Use non-standard port to avoid conflict with any running dev server
const VIEWPORT = { width: 1440, height: 900 };  // Standard 16:10 screenshot size
```

Helper functions needed:
- `findRsfCommand(repoRoot, workflowPath, port)`: Same venv detection logic as start-ui-server.ts — check `.venv/bin/rsf` first, fall back to PATH, include `--no-browser` flag
- `waitForReady(url, maxRetries, intervalMs)`: HTTP health-check polling (same pattern as existing scripts)
- `startProcess(command, args, cwd, label)`: Spawn child process, pipe stdout/stderr with `[label]` prefix, return ChildProcess
- `stopProcess(child, label)`: SIGTERM with 2s SIGKILL fallback, return Promise
- `waitForServer(url, label, maxRetries?, intervalMs?)`: Combine startProcess + waitForReady, throw if timeout

**Graph editor screenshot capture (for each example):**

1. Resolve workflow path: `{repoRoot}/examples/{example}/workflow.yaml`
2. Start rsf ui server with the workflow on UI_PORT
3. Health-check `http://127.0.0.1:{UI_PORT}/` (30 retries, 500ms interval)
4. Navigate Playwright page to `http://127.0.0.1:{UI_PORT}/`
5. Wait for the graph to render:
   - Wait for `.react-flow` container to be visible
   - Wait for at least one `.react-flow__node` element to appear (proves nodes loaded)
   - Add a small delay (1000ms) for ELK layout to stabilize
6. **Full-layout screenshot** (`{example}-graph.png`):
   - Take full page screenshot with `page.screenshot({ path: outputPath, fullPage: false })`
7. **DSL-editing screenshot** (`{example}-dsl.png`):
   - The Monaco editor and graph are always both visible in the layout
   - Take the same viewport screenshot — both panels are visible simultaneously
   - This captures the "DSL editing" view showing YAML alongside the graph
8. Stop rsf ui server

**Inspector screenshot capture (for each example):**

1. Start mock inspect server on INSPECT_PORT: `spawn('node', ['--import', 'tsx/esm', mockServerScript, '--fixture', example, '--port', String(INSPECT_PORT)], { cwd: uiDir })`
2. Health-check `http://127.0.0.1:{INSPECT_PORT}/api/inspect/executions`
3. Start Vite dev server on VITE_PORT: `spawn('npx', ['vite', '--port', String(VITE_PORT), '--strictPort'], { cwd: uiDir })`
4. Health-check `http://127.0.0.1:{VITE_PORT}/` (Vite serves the SPA, proxies /api/inspect to INSPECT_PORT)
5. Navigate Playwright page to `http://127.0.0.1:{VITE_PORT}/#/inspector`
6. Wait for execution list to load:
   - Wait for `.execution-list-item` elements to appear
7. Click the first execution in the list to trigger SSE streaming
8. Wait for inspector to populate:
   - Wait for `.react-flow__node` inside `.inspector-center` to appear (graph rendered)
   - Wait for `.event-timeline-item` or similar timeline element (events loaded)
   - Add a small delay (1500ms) for graph layout and SSE to complete
9. **Inspector screenshot** (`{example}-inspector.png`):
   - Take viewport screenshot
10. Stop Vite dev server, then stop mock inspect server

**Output directory:**
- Create `docs/images/` if it doesn't exist: `mkdirSync(docsImagesDir, { recursive: true })`
- All screenshots go to `{repoRoot}/docs/images/{example}-{type}.png`

**Error handling:**
- Wrap each example in try/catch so one failure doesn't prevent others
- Always clean up servers in finally blocks
- Log progress: "Capturing screenshots for {example} ({N}/{total})..."
- On completion, log summary: "Captured {success}/{total} screenshots. Output: docs/images/"
- Exit with code 1 if any screenshots failed

**Process cleanup:**
- Keep a Set of active child processes
- Register process.on('SIGINT') and process.on('SIGTERM') handlers that kill all active children
- Use process.on('exit') as a final safety net

**Important Vite detail:**
The Vite dev server proxy in vite.config.ts hardcodes target ports (8765 for /api and /ws, 8766 for /api/inspect). The capture script MUST use these exact ports for rsf ui (8765) and mock inspect (8766) so Vite's proxy configuration works correctly. For Vite's own port, use a different port (VITE_PORT = 5199) to avoid conflicts.

**Important DSL screenshot detail:**
The graph editor layout always shows Palette + MonacoEditor + GraphCanvas side by side. For the DSL screenshot, focus on making the YAML editor prominent. Since both panels are always visible in the default layout, the DSL screenshot should be differentiated from the full-layout screenshot. Approach: For the full-layout (graph) screenshot, hide the editor pane by setting its display to none via page.evaluate, then take a wider graph-only screenshot. For the DSL screenshot, show the normal layout with both panels visible. This way:
- `{example}-graph.png` = Graph-focused view (palette hidden, editor hidden, full-width graph)
- `{example}-dsl.png` = Full editor layout (palette + YAML editor + graph side by side)
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python/ui && node --import tsx/esm scripts/capture-screenshots.ts 2>&1 | tail -5</automated>
  </verify>
  <done>
    - capture-screenshots.ts exists and is executable via node --import tsx/esm
    - Running the script produces 15 PNG files in docs/images/
    - Each PNG is non-empty (> 10KB indicating actual rendered content)
    - Graph screenshots show nodes (not blank pages)
    - Inspector screenshots show execution data (not empty panels)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm run screenshots script and verify all 15 outputs</name>
  <files>ui/package.json</files>
  <action>
Add the `screenshots` script to ui/package.json scripts section:

```json
"screenshots": "node --import tsx/esm scripts/capture-screenshots.ts"
```

Add it after the existing `smoke-test` entry in the scripts object.

Then verify the complete pipeline works by running `npm run screenshots` and checking all 15 output files:

1. Run `npm run screenshots` from ui/
2. Verify all 15 files exist in docs/images/:
   - order-processing-graph.png, order-processing-dsl.png, order-processing-inspector.png
   - approval-workflow-graph.png, approval-workflow-dsl.png, approval-workflow-inspector.png
   - data-pipeline-graph.png, data-pipeline-dsl.png, data-pipeline-inspector.png
   - retry-and-recovery-graph.png, retry-and-recovery-dsl.png, retry-and-recovery-inspector.png
   - intrinsic-showcase-graph.png, intrinsic-showcase-dsl.png, intrinsic-showcase-inspector.png
3. Verify each file is > 10KB (real rendered content, not blank/error pages)
4. Run `npm run screenshots` a second time to verify idempotent overwrite works
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python/ui && npm run screenshots 2>&1 | tail -3 && ls -la ../docs/images/*.png | wc -l && ls -la ../docs/images/*.png | awk '{print $5, $NF}' | sort</automated>
  </verify>
  <done>
    - `npm run screenshots` in ui/ completes successfully (exit code 0)
    - All 15 PNG files exist in docs/images/
    - Each file is > 10KB (real content)
    - Re-running overwrites existing files without error
    - No manual intervention required at any point
  </done>
</task>

</tasks>

<verification>
1. `cd ui && npm run screenshots` exits with code 0
2. `ls docs/images/*.png | wc -l` returns 15
3. `find docs/images/ -name "*.png" -size +10k | wc -l` returns 15 (all non-trivial size)
4. Running `npm run screenshots` a second time still exits 0 and overwrites existing files
5. No servers left running after script completes (check with `lsof -i :8765,8766,5199` shows no listeners)
</verification>

<success_criteria>
- 15 PNG screenshots exist in docs/images/ covering all 5 examples x 3 views
- `npm run screenshots` in ui/ regenerates all screenshots in one command without manual intervention
- Graph editor screenshots show rendered workflow graphs with nodes and edges
- DSL screenshots show the YAML editor panel alongside the graph
- Inspector screenshots show populated execution data with timeline and state information
- Script is idempotent — re-running produces the same result
</success_criteria>

<output>
After completion, create `.planning/phases/23-screenshot-capture/23-01-SUMMARY.md`
</output>
