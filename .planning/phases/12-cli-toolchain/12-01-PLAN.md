---
phase: 12-cli-toolchain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rsf/cli/__init__.py
  - src/rsf/cli/main.py
  - src/rsf/cli/init_cmd.py
  - src/rsf/cli/templates/workflow.yaml
  - src/rsf/cli/templates/handler_example.py
  - src/rsf/cli/templates/test_example.py
  - src/rsf/cli/templates/gitignore
  - src/rsf/cli/templates/pyproject.toml.j2
  - tests/test_cli/__init__.py
  - tests/test_cli/test_main.py
  - tests/test_cli/test_init.py
autonomous: true
requirements:
  - CLI-01
  - CLI-08

must_haves:
  truths:
    - "Running `rsf --version` prints the RSF version string"
    - "Running `rsf --help` shows all available subcommands"
    - "Running `rsf init my-project` creates a directory with workflow.yaml, handlers/, pyproject.toml, and .gitignore"
    - "Running `rsf init` in an existing directory with a workflow.yaml exits with an error instead of overwriting"
  artifacts:
    - path: "src/rsf/cli/main.py"
      provides: "Typer app with --version callback and subcommand registration"
      exports: ["app"]
    - path: "src/rsf/cli/init_cmd.py"
      provides: "rsf init subcommand implementation"
      contains: "def init"
    - path: "tests/test_cli/test_init.py"
      provides: "Tests for init scaffold"
      min_lines: 30
  key_links:
    - from: "pyproject.toml"
      to: "src/rsf/cli/main.py"
      via: "project.scripts entry point"
      pattern: 'rsf = "rsf.cli.main:app"'
    - from: "src/rsf/cli/main.py"
      to: "src/rsf/__init__.py"
      via: "__version__ import for --version flag"
      pattern: "from rsf import __version__"
---

<objective>
Create the Typer CLI skeleton with `--version` flag and `rsf init` project scaffold subcommand.

Purpose: Establish the CLI entry point that all other subcommands will register with, and deliver the first user-facing command that creates a working RSF project from scratch.

Output: `src/rsf/cli/main.py` (Typer app), `src/rsf/cli/init_cmd.py` (init command), scaffold templates, tests.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/rsf/__init__.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Typer CLI skeleton with --version flag and subcommand stubs</name>
  <files>
    src/rsf/cli/__init__.py
    src/rsf/cli/main.py
    tests/test_cli/__init__.py
    tests/test_cli/test_main.py
  </files>
  <action>
    Create the main Typer application in `src/rsf/cli/main.py`:
    1. Import Typer and create `app = typer.Typer(name="rsf", help="RSF — Replacement for Step Functions", no_args_is_help=True)`
    2. Add a `--version` callback using `typer.Option("--version", callback=version_callback, is_eager=True)` that prints `f"rsf {__version__}"` (import `__version__` from `rsf`)
    3. Register placeholder subcommands that will be replaced by real implementations in plans 12-02, 12-03, 12-04. For now, just the `init` subcommand.
    4. Update `src/rsf/cli/__init__.py` to export `app`.

    The entry point `rsf = "rsf.cli.main:app"` already exists in pyproject.toml — verify it matches.

    Use `typer.echo()` for output and `typer.Exit()` for clean exits. Use Rich console for styled output via `rich.console.Console`. Import Rich — it is already a dependency.

    Create `tests/test_cli/__init__.py` (empty) and `tests/test_cli/test_main.py`:
    - Use `typer.testing.CliRunner` to invoke the app
    - Test `rsf --version` prints version string with exit code 0
    - Test `rsf --help` shows "RSF" and subcommand names with exit code 0
    - Test `rsf` with no args shows help (no_args_is_help=True)
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_main.py -x -v</automated>
    <manual>Run `python -m rsf.cli.main --version` and verify it prints "rsf 0.1.0"</manual>
  </verify>
  <done>
    `rsf --version` prints "rsf 0.1.0" with exit code 0. `rsf --help` lists available subcommands. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rsf init scaffold command with templates and tests</name>
  <files>
    src/rsf/cli/init_cmd.py
    src/rsf/cli/main.py
    src/rsf/cli/templates/workflow.yaml
    src/rsf/cli/templates/handler_example.py
    src/rsf/cli/templates/test_example.py
    src/rsf/cli/templates/gitignore
    src/rsf/cli/templates/pyproject.toml.j2
    tests/test_cli/test_init.py
  </files>
  <action>
    Create `src/rsf/cli/init_cmd.py` with an `init` function registered as `@app.command()`:

    **Signature:** `def init(project_name: str = typer.Argument(..., help="Name of the project to create"))`

    **Behavior:**
    1. Create directory `project_name/` in the current working directory
    2. If `project_name/workflow.yaml` already exists, print error via `rich.console.Console().print("[red]Error:[/red] ...")` and `raise typer.Exit(code=1)`
    3. Create scaffold files from templates bundled in `src/rsf/cli/templates/`:
       - `workflow.yaml` — minimal valid RSF workflow (rsf_version: "1.0", StartAt, one Pass state + one Succeed state)
       - `handlers/` directory with empty `__init__.py`
       - `handlers/example_handler.py` — a sample handler using `@state` decorator (copy from template)
       - `pyproject.toml` — rendered from Jinja2 template with project_name, rsf dependency
       - `.gitignore` — Python gitignore with `.terraform/`, `*.tfstate*`, `__pycache__/`
       - `tests/` directory with `__init__.py` and a `test_example.py` skeleton
    4. Print success summary listing all created files using Rich formatting
    5. The entire scaffold must complete in under 2 seconds (it's pure file I/O, should be ~10ms)

    **Template files** (create in `src/rsf/cli/templates/`):
    - `workflow.yaml`: Static file, copy as-is
    - `handler_example.py`: Static file with `@state` decorator example
    - `test_example.py`: Static file with pytest test skeleton
    - `gitignore`: Static file (no dot prefix, renamed on copy)
    - `pyproject.toml.j2`: Jinja2 template with `{{ project_name }}` placeholder

    Use `importlib.resources` or `Path(__file__).parent / "templates"` to locate templates at runtime. Prefer the Path approach for simplicity since the package uses hatchling with `packages = ["src/rsf"]`.

    Register the init command in `main.py` by importing and adding: `app.command()(init_cmd.init)` or using `app.add_typer()`.

    **Tests** in `tests/test_cli/test_init.py`:
    - Use `tmp_path` fixture and `monkeypatch.chdir(tmp_path)` to isolate
    - Test: `rsf init my-project` creates all expected files (workflow.yaml, handlers/__init__.py, pyproject.toml, .gitignore, tests/)
    - Test: `rsf init my-project` twice fails on second run with exit code 1
    - Test: Created workflow.yaml is valid YAML parseable by rsf.dsl.parser.load_yaml
    - Test: Created pyproject.toml contains the project name
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_init.py -x -v</automated>
    <manual>Run `python -m rsf.cli.main init test-project && ls -la test-project/` and verify scaffold</manual>
  </verify>
  <done>
    `rsf init my-project` creates a complete project scaffold with workflow.yaml, handlers/, pyproject.toml, .gitignore, and tests/. Running init on an existing project returns error exit code 1. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_cli/ -x -v` — all CLI tests pass
2. `rsf --version` prints version string
3. `rsf init test-project` creates complete scaffold in under 2 seconds
4. `rsf init test-project` (again) fails with error message
</verification>

<success_criteria>
- Typer CLI app at `src/rsf/cli/main.py` with `--version` flag working
- `rsf init` creates a valid, complete project scaffold
- Entry point in pyproject.toml matches: `rsf = "rsf.cli.main:app"`
- All tests in `tests/test_cli/` pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-cli-toolchain/12-01-SUMMARY.md`
</output>
