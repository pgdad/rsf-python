---
phase: 12-cli-toolchain
plan: 04
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/rsf/cli/import_cmd.py
  - src/rsf/cli/ui_cmd.py
  - src/rsf/cli/inspect_cmd.py
  - src/rsf/cli/main.py
  - tests/test_cli/test_import.py
  - tests/test_cli/test_ui.py
  - tests/test_cli/test_inspect_cmd.py
autonomous: true
requirements:
  - CLI-05
  - CLI-06
  - CLI-07

must_haves:
  truths:
    - "Running `rsf import asl.json` produces workflow.yaml and handler stubs"
    - "Running `rsf import asl.json --output custom.yaml` writes to the specified path"
    - "Running `rsf import` on malformed JSON prints a clear error, not a stack trace"
    - "Running `rsf ui` launches the graph editor FastAPI server and opens a browser"
    - "Running `rsf ui --port 9000` uses the specified port"
    - "Running `rsf inspect --arn <arn>` launches the inspector server with the given ARN"
    - "Running `rsf inspect` with no ARN attempts to discover ARN from terraform output"
  artifacts:
    - path: "src/rsf/cli/import_cmd.py"
      provides: "rsf import subcommand"
      contains: "def import_asl"
    - path: "src/rsf/cli/ui_cmd.py"
      provides: "rsf ui subcommand"
      contains: "def ui"
    - path: "src/rsf/cli/inspect_cmd.py"
      provides: "rsf inspect subcommand"
      contains: "def inspect"
    - path: "tests/test_cli/test_import.py"
      provides: "Tests for import subcommand"
      min_lines: 30
  key_links:
    - from: "src/rsf/cli/import_cmd.py"
      to: "src/rsf/importer/converter.py"
      via: "import_asl() pipeline call"
      pattern: "from rsf.importer.converter import import_asl"
    - from: "src/rsf/cli/ui_cmd.py"
      to: "src/rsf/editor/server.py"
      via: "launch() server start"
      pattern: "from rsf.editor.server import launch"
    - from: "src/rsf/cli/inspect_cmd.py"
      to: "src/rsf/inspect/server.py"
      via: "launch() server start"
      pattern: "from rsf.inspect.server import launch"
---

<objective>
Implement the `rsf import`, `rsf ui`, and `rsf inspect` subcommands that wire existing modules into CLI commands.

Purpose: Complete the CLI toolchain so users can import ASL workflows, launch the visual graph editor, and launch the execution inspector — all from the terminal.

Output: `src/rsf/cli/import_cmd.py`, `src/rsf/cli/ui_cmd.py`, `src/rsf/cli/inspect_cmd.py`, tests.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cli-toolchain/12-01-SUMMARY.md
@src/rsf/importer/converter.py
@src/rsf/editor/server.py
@src/rsf/inspect/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rsf import subcommand with output and handler stub options</name>
  <files>
    src/rsf/cli/import_cmd.py
    src/rsf/cli/main.py
    tests/test_cli/test_import.py
  </files>
  <action>
    Create `src/rsf/cli/import_cmd.py`:

    **Note:** The command function must NOT be named `import` (Python reserved keyword). Name it `import_asl` and register with `@app.command(name="import")`.

    **Signature:**
    ```
    def import_asl(
        asl_file: Path = typer.Argument(..., help="Path to ASL JSON file"),
        output: Path = typer.Option("workflow.yaml", "--output", "-o", help="Output YAML file path"),
        handlers_dir: Path = typer.Option("handlers", "--handlers", help="Handler stubs output directory"),
    )
    ```

    **Behavior:**
    1. Check ASL file exists; error and exit 1 if not
    2. Call `rsf.importer.converter.import_asl(source=asl_file, output_path=output, handlers_dir=handlers_dir)`
    3. Catch `ValueError` (malformed JSON, file not found) — print user-friendly error with Rich, exit 1
    4. Print warnings from `result.warnings` using `[yellow]Warning:[/yellow]` prefix for each
    5. Print success summary: output file path, number of handler stubs created, list of task state names found
    6. If output file already exists, warn but overwrite (the import is intentional conversion, not generation gap)

    Register in `main.py` with `app.command(name="import")`.

    **Tests** in `tests/test_cli/test_import.py`:
    - Use `CliRunner` and `tmp_path`
    - Create a minimal valid ASL JSON file in tmp_path: `{"StartAt": "MyTask", "States": {"MyTask": {"Type": "Task", "Resource": "arn:aws:lambda:us-east-1:123:function:my-fn", "End": true}}}`
    - Test: `rsf import asl.json` produces workflow.yaml in current directory
    - Test: `rsf import asl.json --output custom.yaml` writes to custom path
    - Test: File not found → exit 1
    - Test: Malformed JSON → exit 1 with user-friendly message (not stack trace)
    - Test: Warnings are displayed for Resource fields that were stripped
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_import.py -x -v</automated>
  </verify>
  <done>
    `rsf import asl.json` converts ASL to workflow.yaml with handler stubs. Malformed JSON shows clean error. Warnings display for unsupported fields. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rsf ui and rsf inspect subcommands with server launch and browser open</name>
  <files>
    src/rsf/cli/ui_cmd.py
    src/rsf/cli/inspect_cmd.py
    src/rsf/cli/main.py
    tests/test_cli/test_ui.py
    tests/test_cli/test_inspect_cmd.py
  </files>
  <action>
    **Create `src/rsf/cli/ui_cmd.py`:**

    **Signature:**
    ```
    def ui(
        workflow: Path = typer.Argument("workflow.yaml", help="Path to workflow YAML file"),
        port: int = typer.Option(8765, "--port", "-p", help="Port to serve on"),
        no_browser: bool = typer.Option(False, "--no-browser", help="Don't auto-open browser"),
    )
    ```

    **Behavior:**
    1. Print `[blue]Starting RSF Graph Editor on port {port}...[/blue]`
    2. Call `rsf.editor.server.launch(workflow_path=str(workflow), port=port, open_browser=not no_browser)`
    3. This is a blocking call (uvicorn.run) — the process runs until Ctrl+C
    4. Catch `KeyboardInterrupt` gracefully — print `[dim]Server stopped[/dim]`

    **Create `src/rsf/cli/inspect_cmd.py`:**

    **Signature:**
    ```
    def inspect(
        arn: str = typer.Option(None, "--arn", help="Lambda function ARN to inspect"),
        port: int = typer.Option(8766, "--port", "-p", help="Port to serve on"),
        no_browser: bool = typer.Option(False, "--no-browser", help="Don't auto-open browser"),
        tf_dir: Path = typer.Option("terraform", "--tf-dir", help="Terraform directory for ARN discovery"),
    )
    ```

    **Behavior:**
    1. If `--arn` is not provided, attempt ARN discovery:
       a. Check if `{tf_dir}/terraform.tfstate` exists
       b. If it exists, run `subprocess.run(["terraform", "output", "-raw", "function_arn"], cwd=tf_dir, capture_output=True, text=True)` to get the ARN
       c. If that fails or tf_dir doesn't exist, print `[red]Error:[/red] No --arn provided and could not discover ARN from Terraform state. Use --arn <function-arn>.` and exit 1
    2. Print `[blue]Starting RSF Inspector on port {port}...[/blue]`
    3. Print `[dim]Inspecting: {arn}[/dim]`
    4. Call `rsf.inspect.server.launch(function_name=arn, port=port, open_browser=not no_browser)`
    5. Catch `KeyboardInterrupt` — print `[dim]Server stopped[/dim]`

    Register both in `main.py`.

    **Tests** in `tests/test_cli/test_ui.py`:
    - Mock `rsf.editor.server.launch` to prevent actual server start
    - Test: `rsf ui` calls launch with default workflow.yaml and port 8765
    - Test: `rsf ui my-workflow.yaml --port 9000 --no-browser` passes correct args
    - Test: Verify launch is called with `open_browser=True` by default and `open_browser=False` with `--no-browser`

    **Tests** in `tests/test_cli/test_inspect_cmd.py`:
    - Mock `rsf.inspect.server.launch` to prevent actual server start
    - Mock `subprocess.run` for terraform output discovery
    - Test: `rsf inspect --arn arn:aws:lambda:us-east-2:123:function:my-fn` calls launch with the ARN
    - Test: `rsf inspect` with no ARN and no terraform state → exit 1
    - Test: `rsf inspect` with terraform state available → reads ARN from terraform output
    - Test: Port and no-browser flags passed correctly
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest tests/test_cli/test_ui.py tests/test_cli/test_inspect_cmd.py -x -v</automated>
  </verify>
  <done>
    `rsf ui` launches graph editor server with auto-browser-open. `rsf inspect --arn <arn>` launches inspector. `rsf inspect` without --arn attempts terraform output discovery. All tests pass with mocked servers.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_cli/test_import.py tests/test_cli/test_ui.py tests/test_cli/test_inspect_cmd.py -x -v` — all tests pass
2. `rsf import --help` shows ASL file argument and --output option
3. `rsf ui --help` shows workflow argument, --port, --no-browser options
4. `rsf inspect --help` shows --arn, --port, --no-browser, --tf-dir options
</verification>

<success_criteria>
- `rsf import asl.json` converts ASL JSON to workflow.yaml + handler stubs with clean error handling
- `rsf ui` launches graph editor server on port 8765 with auto-browser-open
- `rsf inspect` launches inspector with ARN from --arn flag or terraform output discovery
- All three subcommands handle errors gracefully with Rich-formatted messages
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-cli-toolchain/12-04-SUMMARY.md`
</output>
