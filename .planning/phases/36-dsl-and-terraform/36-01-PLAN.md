---
phase: 36-dsl-and-terraform
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rsf/dsl/models.py
  - src/rsf/dsl/types.py
  - src/rsf/dsl/__init__.py
  - tests/test_dsl/test_models.py
  - tests/test_dsl/test_validator.py
autonomous: true
requirements: [DSL-01, DSL-02]

must_haves:
  truths:
    - "User can add `lambda_url: {enabled: true, auth_type: NONE}` to workflow YAML and it parses without error"
    - "User can add `lambda_url: {enabled: true, auth_type: AWS_IAM}` to workflow YAML and it parses without error"
    - "Omitting `lambda_url` entirely from workflow YAML still parses correctly (backward compatible)"
    - "`rsf validate` rejects invalid auth_type values (e.g., `auth_type: BASIC`) with a clear error"
    - "`rsf validate` rejects `lambda_url: {enabled: true}` without auth_type"
    - "The `lambda_url` field is accessible on the parsed StateMachineDefinition object as `definition.lambda_url`"
  artifacts:
    - path: "src/rsf/dsl/types.py"
      provides: "LambdaUrlAuthType enum with NONE and AWS_IAM values"
      contains: "class LambdaUrlAuthType"
    - path: "src/rsf/dsl/models.py"
      provides: "LambdaUrlConfig model and lambda_url field on StateMachineDefinition"
      contains: "class LambdaUrlConfig"
    - path: "tests/test_dsl/test_models.py"
      provides: "Tests for LambdaUrlConfig parsing, validation, and backward compatibility"
      contains: "TestLambdaUrlConfig"
  key_links:
    - from: "src/rsf/dsl/models.py"
      to: "src/rsf/dsl/types.py"
      via: "import LambdaUrlAuthType"
      pattern: "from rsf.dsl.types import.*LambdaUrlAuthType"
    - from: "src/rsf/dsl/models.py"
      to: "src/rsf/dsl/__init__.py"
      via: "LambdaUrlConfig exported in __all__"
      pattern: "LambdaUrlConfig"
---

<objective>
Add optional `lambda_url` configuration support to the RSF DSL: a new `LambdaUrlConfig` Pydantic model with `enabled` (bool) and `auth_type` (NONE|AWS_IAM), attached as an optional field on `StateMachineDefinition`. Includes validation that rejects invalid auth types and comprehensive tests.

Purpose: This is the foundation for Phase 36 — the DSL model must exist before Terraform generation can consume it (Plan 02 depends on this).
Output: Updated DSL models, types, and exports; new tests covering all lambda_url parsing and validation scenarios.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/rsf/dsl/types.py (add new enum here):
```python
class QueryLanguage(str, Enum):
    JSONPATH = "JSONPath"
    JSONATA = "JSONata"

class JitterStrategy(str, Enum):
    FULL = "FULL"
    NONE = "NONE"

class ProcessorMode(str, Enum):
    INLINE = "INLINE"
    DISTRIBUTED = "DISTRIBUTED"
```

From src/rsf/dsl/models.py (add new model and field here):
```python
class StateMachineDefinition(BaseModel):
    model_config = {"extra": "forbid", "populate_by_name": True}

    rsf_version: str = Field(default="1.0", alias="rsf_version")
    comment: str | None = Field(default=None, alias="Comment")
    start_at: str = Field(alias="StartAt")
    states: dict[str, Any] = Field(alias="States")
    version: str | None = Field(default=None, alias="Version")
    timeout_seconds: int | None = Field(default=None, alias="TimeoutSeconds", ge=0)
    query_language: QueryLanguage | None = Field(default=None, alias="QueryLanguage")
```

From src/rsf/dsl/__init__.py (exports to update):
```python
__all__ = [
    "BooleanAndRule", "BooleanNotRule", "BooleanOrRule", "BranchDefinition",
    "Catcher", "ChoiceRule", "ChoiceState", "COMPARISON_OPERATORS",
    "ConditionRule", "DataTestRule", "FailState", "JitterStrategy",
    "MapState", "ParallelState", "PassState", "ProcessorConfig",
    "ProcessorMode", "QueryLanguage", "RetryPolicy", "State",
    "StateMachineDefinition", "SucceedState", "TaskState", "WaitState",
    "discriminate_choice_rule",
]
```

From tests/test_dsl/test_models.py (test pattern):
```python
class TestTaskState:
    def test_basic_task(self):
        sm = StateMachineDefinition.model_validate({
            "StartAt": "T",
            "States": {"T": {"Type": "Task", "End": True}},
        })
        assert isinstance(sm.states["T"], TaskState)
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add LambdaUrlAuthType enum and LambdaUrlConfig model to DSL</name>
  <files>src/rsf/dsl/types.py, src/rsf/dsl/models.py, src/rsf/dsl/__init__.py, tests/test_dsl/test_models.py</files>
  <behavior>
    - Test: StateMachineDefinition parses with `lambda_url: {enabled: true, auth_type: "NONE"}` — result has `definition.lambda_url.enabled == True` and `definition.lambda_url.auth_type == LambdaUrlAuthType.NONE`
    - Test: StateMachineDefinition parses with `lambda_url: {enabled: true, auth_type: "AWS_IAM"}` — `definition.lambda_url.auth_type == LambdaUrlAuthType.AWS_IAM`
    - Test: StateMachineDefinition parses with `lambda_url: {enabled: false, auth_type: "NONE"}` — `definition.lambda_url.enabled == False`
    - Test: StateMachineDefinition parses without `lambda_url` field — `definition.lambda_url is None` (backward compatibility)
    - Test: StateMachineDefinition rejects `lambda_url: {enabled: true, auth_type: "BASIC"}` — raises ValidationError
    - Test: StateMachineDefinition rejects `lambda_url: {enabled: true}` (missing auth_type) — raises ValidationError
    - Test: StateMachineDefinition rejects `lambda_url: {auth_type: "NONE"}` (missing enabled) — raises ValidationError
    - Test: StateMachineDefinition rejects extra fields in lambda_url (e.g., `lambda_url: {enabled: true, auth_type: "NONE", cors: true}`) — raises ValidationError
  </behavior>
  <action>
1. **src/rsf/dsl/types.py** — Add a new `LambdaUrlAuthType` enum after the `ProcessorMode` enum:
   ```python
   class LambdaUrlAuthType(str, Enum):
       """Authentication types for Lambda Function URL."""
       NONE = "NONE"
       AWS_IAM = "AWS_IAM"
   ```

2. **src/rsf/dsl/models.py** — Add `LambdaUrlConfig` model and update `StateMachineDefinition`:
   - Import `LambdaUrlAuthType` from `rsf.dsl.types`
   - Add the `LambdaUrlConfig` model (before `StateMachineDefinition`):
     ```python
     class LambdaUrlConfig(BaseModel):
         """Configuration for Lambda Function URL."""
         model_config = {"extra": "forbid"}

         enabled: bool
         auth_type: LambdaUrlAuthType
     ```
   - Add `lambda_url` field to `StateMachineDefinition`:
     ```python
     lambda_url: LambdaUrlConfig | None = Field(default=None, alias="lambda_url")
     ```
   Note: Use `alias="lambda_url"` (snake_case) since this is an RSF-specific extension field, not an ASL field. The existing `rsf_version` field follows this same convention (snake_case alias for RSF extensions vs PascalCase alias for ASL fields).

3. **src/rsf/dsl/__init__.py** — Add imports and exports:
   - Import `LambdaUrlConfig` from `rsf.dsl.models`
   - Import `LambdaUrlAuthType` from `rsf.dsl.types`
   - Add both to `__all__`

4. **tests/test_dsl/test_models.py** — Add a new `TestLambdaUrlConfig` test class at the end of the file with all the behavior tests listed above. Each test should use `StateMachineDefinition.model_validate(...)` with a minimal valid workflow (StartAt + one Succeed state) plus the `lambda_url` field being tested. Use `pytest.raises(ValidationError)` for rejection tests.
  </action>
  <verify>
    <automated>.venv/bin/python -m pytest tests/test_dsl/test_models.py::TestLambdaUrlConfig -xvs 2>&1 | tail -20</automated>
  </verify>
  <done>
  - LambdaUrlAuthType enum exists with NONE and AWS_IAM values
  - LambdaUrlConfig model exists with enabled (bool, required) and auth_type (LambdaUrlAuthType, required) fields
  - StateMachineDefinition has optional lambda_url field defaulting to None
  - All 8 behavior tests pass
  - Existing tests still pass (no regressions)
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify backward compatibility and CLI validation integration</name>
  <files>tests/test_dsl/test_models.py</files>
  <action>
Run the full test suite to verify no regressions:

1. Run all DSL model tests: `pytest tests/test_dsl/test_models.py -xvs`
2. Run all DSL validator tests: `pytest tests/test_dsl/test_validator.py -xvs`
3. Run all CLI validate tests: `pytest tests/test_cli/test_validate.py -xvs`
4. Run the full non-integration suite: `pytest -m "not integration" -q`

The `rsf validate` CLI command already calls `dsl_parser.parse_definition(data)` which uses `StateMachineDefinition.model_validate()`. Since we added `lambda_url` as an optional Pydantic field, the CLI will automatically:
- Accept workflows with valid `lambda_url` blocks
- Reject workflows with invalid `auth_type` values (Pydantic validation)
- Continue working with workflows that omit `lambda_url` entirely

No changes to `validate_cmd.py` are needed — Pydantic handles the validation.

If any existing tests fail due to the model change, fix them. The most likely issue would be if any test creates a `StateMachineDefinition` with extra fields that now conflict with `extra = "forbid"` — but since `lambda_url` uses the snake_case alias convention (matching `rsf_version`), this should not affect existing tests that use PascalCase ASL fields.
  </action>
  <verify>
    <automated>.venv/bin/python -m pytest -m "not integration" -q 2>&1 | tail -5</automated>
  </verify>
  <done>
  - All existing DSL model tests pass (no regressions)
  - All DSL validator tests pass
  - All CLI validate tests pass
  - Full non-integration test suite passes with zero failures
  - `rsf validate` CLI automatically handles lambda_url validation via Pydantic
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_dsl/test_models.py::TestLambdaUrlConfig -v` — all 8 lambda_url tests pass
2. `pytest tests/test_dsl/ -v` — all DSL tests pass (no regressions)
3. `pytest tests/test_cli/test_validate.py -v` — CLI validation tests pass
4. `pytest -m "not integration" -q` — full non-integration suite passes (744+ tests, 0 failures)
5. `ruff check .` — zero lint violations
6. `python -c "from rsf.dsl import LambdaUrlConfig, LambdaUrlAuthType; print('OK')"` — imports succeed
</verification>

<success_criteria>
- LambdaUrlAuthType enum with NONE and AWS_IAM values exists in types.py
- LambdaUrlConfig Pydantic model with enabled (bool) and auth_type (LambdaUrlAuthType) exists in models.py
- StateMachineDefinition has optional lambda_url field (default None)
- Both are exported from rsf.dsl package
- Pydantic validation rejects invalid auth types with clear error messages
- Existing workflows without lambda_url continue to parse correctly
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/36-dsl-and-terraform/36-01-SUMMARY.md`
</output>
