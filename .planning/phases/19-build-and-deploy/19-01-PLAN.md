---
phase: 19-build-and-deploy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tutorials/03-code-generation.md
autonomous: true
requirements:
  - DEPLOY-01

must_haves:
  truths:
    - "User can run rsf generate on a validated workflow and get a working orchestrator file plus handler stubs"
    - "User understands how @state decorators connect handler functions to workflow states"
    - "User can edit the generated handler stub to add custom business logic and re-generate without losing changes"
  artifacts:
    - path: "tutorials/03-code-generation.md"
      provides: "Step-by-step rsf generate tutorial with generated output walkthrough and Generation Gap explanation"
      min_lines: 200
  key_links:
    - from: "tutorials/03-code-generation.md"
      to: "src/rsf/cli/generate_cmd.py"
      via: "Documents the exact behavior of rsf generate"
      pattern: "rsf generate"
    - from: "tutorials/03-code-generation.md"
      to: "src/rsf/codegen/generator.py"
      via: "Documents orchestrator and handler stub generation"
      pattern: "orchestrator.py"
---

<objective>
Create a comprehensive step-by-step tutorial for `rsf generate` that walks users through generating orchestrator code and handler stubs from a validated workflow.

Purpose: Users need a hands-on guide to generate the Python orchestrator and handler stubs, understand the generated code structure, customize handler business logic with `@state` decorators, and learn how the Generation Gap pattern protects their edits on re-generation.
Output: `tutorials/03-code-generation.md` — a complete tutorial document.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/rsf/cli/generate_cmd.py
@src/rsf/codegen/generator.py
@src/rsf/codegen/emitter.py
@src/rsf/codegen/engine.py
@tutorials/01-project-setup.md
@tutorials/02-workflow-validation.md

<interfaces>
<!-- The rsf generate command behavior (from src/rsf/cli/generate_cmd.py):

  Takes one argument: workflow path (defaults to "workflow.yaml")
  Takes one option: --output / -o (defaults to ".")

  Pipeline:
  1. File existence check → "Error: File not found: {path}"
  2. YAML parse → "Error: Invalid YAML in {path}: {exc}"
  3. Non-dict check → "Error: Workflow file must be a YAML mapping, got: {type}"
  4. Pydantic structural validation → "Validation errors in {path}:" + field-path errors
  5. Semantic validation → "Semantic errors in {path}:" + field-path errors
  6. Code generation:
     - Generates orchestrator.py in output_dir
     - Generates handler stubs in output_dir/handlers/ (one per Task state)
     - Skips handler files that already exist and don't have the generated marker (Generation Gap)
  7. Prints summary:
     - "Generated: {orchestrator_path}"
     - "  Created: {handler_path}" for each new handler
     - "  Skipped: {handler_path} (already exists, not overwritten)" for each preserved handler
     - "Summary: orchestrator written, N handler(s) created, M skipped."

  Key behaviors:
  - Validates before generating (same 3-stage pipeline as rsf validate)
  - orchestrator.py is ALWAYS overwritten (has GENERATED_MARKER)
  - Handler stubs are only written if they don't exist OR have the GENERATED_MARKER
  - User-modified handlers (without marker) are NEVER overwritten (Generation Gap pattern)
  - Handler stubs use @state("StateName") decorator
  - Handler function names are snake_case of state name
  - handlers/__init__.py is auto-generated with imports for all task handlers
-->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the rsf generate tutorial</name>
  <files>tutorials/03-code-generation.md</files>
  <action>
Create the file `tutorials/03-code-generation.md` with the following structure and content:

**Title:** "Tutorial 3: Code Generation with `rsf generate`"

**Sections to include (in order):**

1. **What You'll Learn** — Brief overview: generate orchestrator code and handler stubs from a validated workflow, understand the generated code, customize handler logic, and learn how the Generation Gap pattern protects your edits.

2. **Prerequisites** — Completed Tutorials 1 and 2: have a `my-workflow/` directory with a validated `workflow.yaml`. RSF installed.

3. **Step 1: Generate Code from the Starter Workflow** — Show the exact command: `rsf generate`. Include the expected terminal output:
   ```
   Generated: orchestrator.py
     Skipped: handlers/example_handler.py (already exists, not overwritten)

   Summary: orchestrator written, 0 handler(s) created, 1 skipped.
   ```
   Note: The starter workflow created by `rsf init` already includes `handlers/example_handler.py`, so `rsf generate` skips it (Generation Gap). The orchestrator is always regenerated.

4. **Step 2: Explore the Generated Files** — Show the updated directory tree with orchestrator.py added. List the new/modified files:
   - `orchestrator.py` — the generated orchestrator
   - `handlers/example_handler.py` — skipped (already existed from `rsf init`)
   - `handlers/__init__.py` — updated with auto-generated imports

5. **Understanding the Orchestrator** — Show a representative excerpt of `orchestrator.py` (the generated marker header, the import section, and the `lambda_handler` function structure). Explain:
   - The `# DO NOT EDIT - Generated by RSF` marker means this file is always regenerated
   - The orchestrator imports handler functions from `handlers/`
   - The `lambda_handler` function is the Lambda entry point
   - The state machine logic routes execution through states defined in `workflow.yaml`
   - You never need to edit this file — it is regenerated every time you run `rsf generate`

   **IMPORTANT: Do NOT attempt to show the full orchestrator.py content.** Instead, describe its structure and show the key header lines. The exact content depends on the workflow and includes hash/timestamp values. Explain what it does conceptually.

6. **Understanding Handler Stubs** — Remind user of the `handlers/example_handler.py` from Tutorial 1 (already covered there). Explain:
   - The `@state("HelloWorld")` decorator registers the function for the `HelloWorld` state
   - The function receives `event` (state input) and `context` (Lambda context)
   - The return value becomes the output passed to the next state
   - This is where you write your business logic

7. **Step 3: Generate Code from a Multi-State Workflow** — Use the order processing workflow from Tutorial 2 Step 5 (or a similar Task-based workflow). Have the user replace `workflow.yaml` with:
   ```yaml
   rsf_version: "1.0"
   Comment: "Order processing workflow"
   StartAt: ValidateOrder

   States:
     ValidateOrder:
       Type: Task
       Next: CheckAmount

     CheckAmount:
       Type: Choice
       Choices:
         - Variable: "$.amount"
           NumericGreaterThan: 100
           Next: RequireApproval
       Default: ProcessOrder

     RequireApproval:
       Type: Task
       Next: ProcessOrder

     ProcessOrder:
       Type: Task
       End: true
   ```
   Run `rsf generate` and show expected output:
   ```
   Generated: orchestrator.py
     Created: handlers/validate_order.py
     Created: handlers/require_approval.py
     Created: handlers/process_order.py

   Summary: orchestrator written, 3 handler(s) created, 0 skipped.
   ```
   Point out: one handler stub was created per Task state. Choice states don't get handlers — they are routing logic handled by the orchestrator.

8. **Step 4: Customize a Handler** — Walk user through editing `handlers/validate_order.py`:
   - Open the file and show the generated stub content (the @state decorator, the function signature, the TODO placeholder)
   - Replace the stub body with real business logic:
     ```python
     @state("ValidateOrder")
     def validate_order(event: dict, context: dict) -> dict:
         order_id = event.get("order_id")
         amount = event.get("amount", 0)
         if not order_id:
             raise ValueError("Missing order_id")
         return {"order_id": order_id, "amount": amount, "validated": True}
     ```
   - Explain: this is now YOUR code. The `@state` decorator connects it to the `ValidateOrder` state.

9. **Step 5: Re-generate Without Losing Changes (Generation Gap)** — Run `rsf generate` again and show expected output:
   ```
   Generated: orchestrator.py
     Skipped: handlers/validate_order.py (already exists, not overwritten)
     Skipped: handlers/require_approval.py (already exists, not overwritten)
     Skipped: handlers/process_order.py (already exists, not overwritten)

   Summary: orchestrator written, 0 handler(s) created, 3 skipped.
   ```
   Explain the Generation Gap pattern:
   - `orchestrator.py` was regenerated (it always is — the `# DO NOT EDIT - Generated by RSF` marker tells RSF this file is managed)
   - All three handler stubs were skipped because they already exist without the generated marker
   - Your edits to `validate_order.py` are safe — RSF will never overwrite a handler file you have modified
   - If you add a new Task state to the workflow, `rsf generate` will create a stub for it while leaving existing handlers untouched

10. **What's Next** — Point to Tutorial 4 (rsf deploy) for deploying the workflow to AWS. Reinforce: always validate before generating, always generate before deploying.

**Style guidelines (follow exactly):**
- Follow the established tutorial patterns from Tutorials 1 and 2
- Use clear, direct language. No marketing fluff.
- Every command should be in a fenced code block with `bash` syntax highlighting.
- Every file listing should be in a fenced code block with appropriate syntax highlighting (yaml, python, toml).
- When showing a workflow, show the FULL workflow.yaml content so users can copy-paste it exactly.
- Use blockquotes (> ) for important notes or tips.
- Keep explanations concise — 2-4 sentences per concept.
- Do NOT use emojis.
- Reference the actual CLI output format from `generate_cmd.py` (Rich markup-free representation).
  </action>
  <verify>
    <automated>test -f tutorials/03-code-generation.md && wc -l tutorials/03-code-generation.md | awk '{if ($1 >= 200) print "PASS: "$1" lines"; else print "FAIL: only "$1" lines"}'</automated>
  </verify>
  <done>
    - tutorials/03-code-generation.md exists with 200+ lines
    - Tutorial covers: prerequisites, running rsf generate on starter workflow, exploring generated files, understanding orchestrator structure, understanding handler stubs with @state decorator, generating from multi-state workflow, customizing handler logic, re-generating without losing changes (Generation Gap), and pointer to Tutorial 4
    - Concrete commands and expected output matching generate_cmd.py behavior
    - Generation Gap pattern clearly explained with practical demonstration
    - Multi-state workflow uses Task and Choice states to show handler-per-Task generation
  </done>
</task>

</tasks>

<verification>
1. `tutorials/03-code-generation.md` exists and has 200+ lines
2. Tutorial documents rsf generate command with correct default behavior (workflow.yaml, output to current dir)
3. Shows handler generation: one stub per Task state, no stubs for Pass/Choice/Succeed/Fail
4. Generation Gap pattern demonstrated: user edits handler, re-runs generate, handler is preserved
5. Multi-state workflow example is valid RSF YAML (would pass rsf validate)
6. Commands are concrete (`rsf generate`, not `rsf generate <file>`)
</verification>

<success_criteria>
A user reading this tutorial can: run `rsf generate` on a validated workflow, understand the generated orchestrator and handler stubs, customize handler logic with `@state` decorators, and re-generate without losing their changes.
</success_criteria>

<output>
After completion, create `.planning/phases/19-build-and-deploy/19-01-SUMMARY.md`
</output>
