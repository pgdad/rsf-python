---
phase: 19-build-and-deploy
plan: 03
type: execute
wave: 3
depends_on: [19-02]
files_modified:
  - tutorials/05-iterate-invoke-teardown.md
autonomous: true
requirements:
  - DEPLOY-03
  - DEPLOY-04

must_haves:
  truths:
    - "User can run rsf deploy --code-only to update handler logic on an already-deployed Lambda without a full Terraform apply"
    - "User can invoke the deployed Lambda function with a test payload and see the workflow execution result"
    - "User can run the teardown command to remove all AWS resources with zero orphaned infrastructure"
  artifacts:
    - path: "tutorials/05-iterate-invoke-teardown.md"
      provides: "Step-by-step tutorial for code-only deploys, Lambda invocation, and infrastructure teardown"
      min_lines: 200
  key_links:
    - from: "tutorials/05-iterate-invoke-teardown.md"
      to: "src/rsf/cli/deploy_cmd.py"
      via: "Documents the --code-only fast path behavior"
      pattern: "--code-only"
    - from: "tutorials/05-iterate-invoke-teardown.md"
      to: "tutorials/04-deploy-to-aws.md"
      via: "Uses infrastructure deployed in Tutorial 4"
      pattern: "rsf deploy"
---

<objective>
Create a comprehensive step-by-step tutorial covering the `rsf deploy --code-only` fast path for iterating on handler logic, invoking the deployed Lambda to verify it works, and tearing down all infrastructure cleanly.

Purpose: Users need to learn the fast development loop (edit handler, code-only deploy, invoke, verify) and the clean teardown process that leaves zero orphaned AWS resources. This tutorial completes the build-and-deploy cycle.
Output: `tutorials/05-iterate-invoke-teardown.md` — a complete tutorial document.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-build-and-deploy/19-02-SUMMARY.md

@src/rsf/cli/deploy_cmd.py
@tutorials/01-project-setup.md
@tutorials/02-workflow-validation.md

<interfaces>
<!-- The rsf deploy --code-only behavior (from src/rsf/cli/deploy_cmd.py):

  --code-only flow (_deploy_code_only):
  1. Check workflow file exists
  2. Load and validate the workflow
  3. Generate orchestrator + handlers via codegen
     - Prints: "Code generated: orchestrator.py + N handler(s) (M skipped)"
  4. Check terraform binary exists
  5. Check tf_dir exists (must have run full deploy first)
     - If missing: "Error: Terraform directory not found: terraform"
     - "Run rsf deploy first to initialise the infrastructure."
  6. Run targeted terraform apply: terraform apply -target=aws_lambda_function.* -auto-approve
     - Prints: "Running targeted terraform apply (Lambda code update)..."
  7. Prints: "Code update complete"

  Key differences from full deploy:
  - No terraform init (already initialized)
  - No full terraform apply — targets only aws_lambda_function resources
  - Always auto-approves (no interactive prompt)
  - Much faster: seconds vs. minutes
  - Requires prior full deploy (terraform directory must exist with state)

  Lambda invocation (via AWS CLI):
  - aws lambda invoke --function-name {name} --payload '{"key":"value"}' --cli-binary-format raw-in-base64-out output.json
  - The function name follows pattern: rsf-{workflow-comment-or-filename}

  Teardown (via Terraform):
  - cd terraform && terraform destroy -auto-approve
  - Removes: Lambda function, IAM role, IAM policy, CloudWatch log group
  - Leaves zero orphaned resources
-->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the iterate, invoke, and teardown tutorial</name>
  <files>tutorials/05-iterate-invoke-teardown.md</files>
  <action>
Create the file `tutorials/05-iterate-invoke-teardown.md` with the following structure and content:

**Title:** "Tutorial 5: Iterate, Invoke, and Tear Down"

**Sections to include (in order):**

1. **What You'll Learn** — Brief overview: use `--code-only` to rapidly iterate on handler logic without re-applying Terraform, invoke the deployed Lambda with a test payload, verify the output, and tear down all AWS resources cleanly.

2. **Prerequisites** —
   - Completed Tutorial 4: have a deployed RSF workflow in AWS (the order processing workflow)
   - `my-workflow/` directory with `workflow.yaml`, generated code, and `terraform/` directory with state
   - AWS CLI configured and Terraform installed

3. **Step 1: Edit a Handler** — Have the user modify `handlers/validate_order.py` to add a timestamp or extra field to the return value. For example:
   ```python
   from rsf.functions.decorators import state
   import time

   @state("ValidateOrder")
   def validate_order(event: dict, context: dict) -> dict:
       order_id = event.get("order_id")
       amount = event.get("amount", 0)
       if not order_id:
           raise ValueError("Missing order_id")
       return {
           "order_id": order_id,
           "amount": amount,
           "validated": True,
           "validated_at": int(time.time()),
       }
   ```
   Explain: you changed the handler to include a `validated_at` timestamp. Now you need to deploy this change without re-creating all the infrastructure.

4. **Step 2: Deploy Code Only** — Show the exact command: `rsf deploy --code-only`. Show expected output:
   ```
   Code generated: orchestrator.py + 3 handler(s) (3 skipped)

   Running targeted terraform apply (Lambda code update)...
   ...
   Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

   Code update complete
   ```
   Explain the key differences from a full deploy:
   - No `terraform init` — already initialized from the full deploy in Tutorial 4
   - Targets only `aws_lambda_function.*` resources — IAM, CloudWatch, etc. are untouched
   - Always auto-approves — no interactive prompt
   - Completes in seconds, not minutes
   - The code generation step still runs (to regenerate orchestrator.py), but your handlers are preserved (Generation Gap)

   > **When to use --code-only vs full deploy:**
   > Use `--code-only` when you only changed handler logic (Python code). Use a full `rsf deploy` when you changed `workflow.yaml` (added/removed/renamed states) because the Terraform configuration may need updating.

5. **Step 3: Invoke the Lambda** — Show the exact invocation command using AWS CLI:
   ```bash
   aws lambda invoke \
     --function-name rsf-Order-processing-workflow \
     --region us-east-2 \
     --payload '{"order_id": "ORD-001", "amount": 50}' \
     --cli-binary-format raw-in-base64-out \
     response.json
   ```
   Show expected CLI output:
   ```json
   {
       "StatusCode": 200,
       "ExecutedVersion": "$LATEST"
   }
   ```
   Then show viewing the response:
   ```bash
   cat response.json
   ```
   Show representative output demonstrating the workflow executed through the states and returned the final result. The exact format depends on the durable execution runtime, but the response should contain the workflow output.

   Explain:
   - The `--function-name` matches the pattern `rsf-{workflow_name}` where workflow_name comes from the `Comment` field in `workflow.yaml`
   - The `--payload` provides the initial input to the first state (`ValidateOrder`)
   - The response is written to `response.json`
   - The workflow executes all states in sequence (ValidateOrder -> CheckAmount -> ProcessOrder) because the amount (50) is not greater than 100

   Try a second invocation with a high amount to test the Choice branch:
   ```bash
   aws lambda invoke \
     --function-name rsf-Order-processing-workflow \
     --region us-east-2 \
     --payload '{"order_id": "ORD-002", "amount": 200}' \
     --cli-binary-format raw-in-base64-out \
     response-high.json

   cat response-high.json
   ```
   Explain: this time the amount (200) exceeds 100, so the Choice state routes to `RequireApproval` before `ProcessOrder`.

6. **Step 4: Tear Down All Infrastructure** — Show the teardown command:
   ```bash
   cd terraform && terraform destroy -auto-approve
   ```
   Show expected output:
   ```
   ...
   Destroy complete! Resources: 4 destroyed.
   ```
   Explain:
   - `terraform destroy` removes everything that was created by `terraform apply`: the Lambda function, IAM role, IAM policy, and CloudWatch log group
   - The `-auto-approve` flag skips the interactive confirmation
   - After this command, zero AWS resources remain from the tutorial — no orphaned infrastructure
   - The local files (`terraform/`, `orchestrator.py`, `handlers/`) remain on disk for reference

   > **Important:** Always run `terraform destroy` when you are done experimenting. Lambda Durable Functions and CloudWatch log groups incur costs while they exist. The teardown removes all resources cleanly.

7. **Step 5: Verify Clean Teardown** — Show verification that the Lambda no longer exists:
   ```bash
   aws lambda get-function --function-name rsf-Order-processing-workflow --region us-east-2
   ```
   Expected output: an error indicating the function does not exist (ResourceNotFoundException). This confirms the teardown was complete.

8. **The Development Loop** — Summarize the full cycle:
   ```
   1. rsf init       — scaffold project
   2. rsf validate   — check workflow YAML
   3. rsf generate   — create orchestrator + handler stubs
   4. rsf deploy     — deploy to AWS (first time)
   5. Edit handlers  — write business logic
   6. rsf deploy --code-only  — update Lambda code (seconds)
   7. aws lambda invoke       — test the workflow
   8. Repeat steps 5-7
   9. terraform destroy       — tear down when done
   ```

9. **What's Next** — Point to Tutorial 6 (rsf import) in Phase 20 for importing existing ASL workflows. Mention the visual graph editor (`rsf ui`) and execution inspector (`rsf inspect`) as advanced tools covered in later tutorials.

**Style guidelines (follow exactly):**
- Follow the established tutorial patterns from Tutorials 1-4
- Use clear, direct language. No marketing fluff.
- Every command should be in a fenced code block with `bash` syntax highlighting.
- Use blockquotes (> ) for important notes or tips, especially for cost warnings and teardown reminders.
- Keep explanations concise — 2-4 sentences per concept.
- Do NOT use emojis.
- Use us-east-2 as the AWS region throughout (per project tutorial conventions).
- The function name pattern is `rsf-{Comment}` where Comment is from workflow.yaml.
  </action>
  <verify>
    <automated>test -f tutorials/05-iterate-invoke-teardown.md && wc -l tutorials/05-iterate-invoke-teardown.md | awk '{if ($1 >= 200) print "PASS: "$1" lines"; else print "FAIL: only "$1" lines"}'</automated>
  </verify>
  <done>
    - tutorials/05-iterate-invoke-teardown.md exists with 200+ lines
    - Tutorial covers: editing a handler, rsf deploy --code-only with expected output, invoking Lambda with AWS CLI (two payloads testing both Choice branches), terraform destroy teardown, verification of clean teardown, development loop summary
    - --code-only vs full deploy guidance included
    - Cost warning and teardown reminder present
    - AWS region is us-east-2 throughout
    - Zero orphaned infrastructure after teardown
    - Development loop summarized as a clear numbered list
    - Pointer to Phase 20 advanced tutorials
  </done>
</task>

</tasks>

<verification>
1. `tutorials/05-iterate-invoke-teardown.md` exists and has 200+ lines
2. Tutorial documents rsf deploy --code-only with correct behavior (targeted apply, auto-approve)
3. Lambda invocation shown with two test payloads (testing both Choice branches)
4. Teardown via terraform destroy -auto-approve documented
5. Clean teardown verified with aws lambda get-function showing ResourceNotFoundException
6. Development loop (init -> validate -> generate -> deploy -> edit -> code-only -> invoke -> teardown) clearly summarized
7. Cost warnings present for live infrastructure
</verification>

<success_criteria>
A user reading this tutorial can: edit a handler and redeploy in seconds with --code-only, invoke the deployed Lambda with test payloads, verify both Choice branches execute correctly, and tear down all infrastructure leaving zero orphaned resources.
</success_criteria>

<output>
After completion, create `.planning/phases/19-build-and-deploy/19-03-SUMMARY.md`
</output>
