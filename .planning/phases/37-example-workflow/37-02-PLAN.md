---
phase: 37-example-workflow
plan: 02
type: tdd
wave: 2
depends_on: [37-01]
files_modified:
  - examples/lambda-url-trigger/tests/__init__.py
  - examples/lambda-url-trigger/tests/conftest.py
  - examples/lambda-url-trigger/tests/test_local.py
autonomous: true
requirements: [EX-02]
must_haves:
  truths:
    - "pytest -m 'not integration' discovers and runs the example's local tests"
    - "All local tests pass with zero failures"
    - "Tests cover workflow parsing, handler unit tests, and full simulation via MockDurableContext"
  artifacts:
    - path: "examples/lambda-url-trigger/tests/conftest.py"
      provides: "Test fixtures and path setup"
      contains: "clean_registry"
    - path: "examples/lambda-url-trigger/tests/test_local.py"
      provides: "Local tests for workflow parsing, handlers, and simulation"
      contains: "MockDurableContext"
  key_links:
    - from: "examples/lambda-url-trigger/tests/test_local.py"
      to: "examples/lambda-url-trigger/workflow.yaml"
      via: "load_definition"
      pattern: "load_definition"
    - from: "examples/lambda-url-trigger/tests/test_local.py"
      to: "examples/lambda-url-trigger/handlers/"
      via: "handler imports and @state registry"
      pattern: "discover_handlers|get_handler"
    - from: "examples/lambda-url-trigger/tests/conftest.py"
      to: "rsf.registry.registry.clear"
      via: "autouse fixture"
      pattern: "clean_registry"
---

<objective>
Create local tests for the lambda-url-trigger example that verify workflow parsing, handler logic, lambda_url feature validation, and full workflow simulation.

Purpose: Satisfy requirement EX-02 — local tests must pass via `pytest -m "not integration"` with zero failures.

Output: examples/lambda-url-trigger/tests/ with conftest.py and test_local.py
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
@/home/esa/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-example-workflow/37-01-SUMMARY.md
@examples/order-processing/tests/conftest.py
@examples/order-processing/tests/test_local.py
@tests/mock_sdk.py
</context>

<interfaces>
<!-- Key types and contracts from the codebase -->

From examples/order-processing/tests/conftest.py:
```python
# Standard conftest pattern for examples — path setup, registry cleanup
import sys
from pathlib import Path
import pytest
from rsf.registry.registry import clear

_example_root = str(Path(__file__).parent.parent)
_project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, _example_root)
sys.path.insert(0, str(_project_root / "src"))
sys.path.insert(0, str(_project_root / "tests"))

@pytest.fixture(autouse=True)
def clean_registry():
    clear()
    for mod_name in [k for k in sys.modules if k == "handlers" or k.startswith("handlers.")]:
        del sys.modules[mod_name]
    if _example_root in sys.path:
        sys.path.remove(_example_root)
    sys.path.insert(0, _example_root)
    yield
    clear()
```

From tests/mock_sdk.py:
```python
class MockDurableContext:
    # Simulates SDK step, wait, parallel, map primitives
    def step(self, name, fn, input_data): ...
    # Records all calls in self.history
```

From rsf.dsl.models:
```python
class LambdaUrlConfig(BaseModel):
    enabled: bool
    auth_type: LambdaUrlAuthType

class StateMachineDefinition(BaseModel):
    lambda_url: LambdaUrlConfig | None = Field(default=None, alias="lambda_url")
```

From rsf.dsl.parser:
```python
def load_definition(path: str | Path) -> StateMachineDefinition
```

From rsf.registry:
```python
def discover_handlers(handlers_dir: Path) -> None
def get_handler(state_name: str) -> Callable
```
</interfaces>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create conftest.py and test_local.py</name>
  <files>
    examples/lambda-url-trigger/tests/__init__.py
    examples/lambda-url-trigger/tests/conftest.py
    examples/lambda-url-trigger/tests/test_local.py
  </files>
  <behavior>
    - Workflow parsing: load_definition succeeds on workflow.yaml
    - Workflow parsing: StartAt is "ValidateOrder"
    - Workflow parsing: rsf_version is "1.0"
    - Workflow parsing: all 3 states present (ValidateOrder, ProcessOrder, OrderComplete)
    - Workflow parsing: state types are correct (Task, Task, Succeed)
    - Lambda URL feature: lambda_url config is present and enabled
    - Lambda URL feature: auth_type is NONE
    - Handler: validate_order accepts valid order and returns validation result
    - Handler: validate_order rejects order with no items
    - Handler: validate_order rejects order with negative total
    - Handler: process_order accepts validated order and returns processed result
    - Simulation: full workflow ValidateOrder -> ProcessOrder -> OrderComplete via MockDurableContext
  </behavior>
  <action>
**tests/__init__.py** — Empty file.

**tests/conftest.py** — Copy the exact pattern from `examples/order-processing/tests/conftest.py`:
- Path setup for example root, project src, and tests (for mock_sdk)
- `clean_registry` autouse fixture that clears registry and purges cached handler modules between tests

**tests/test_local.py** — Follow the 4-section pattern from `examples/order-processing/tests/test_local.py`:

**Section 1: Workflow YAML Parsing Tests** (TestWorkflowParsing class)
- `test_load_definition_succeeds` — workflow.yaml parses without errors
- `test_start_at` — StartAt is "ValidateOrder"
- `test_rsf_version` — rsf_version is "1.0"
- `test_all_states_present` — 3 states: ValidateOrder, ProcessOrder, OrderComplete
- `test_state_types` — ValidateOrder is TaskState, ProcessOrder is TaskState, OrderComplete is SucceedState

**Section 2: Lambda URL Feature Tests** (TestLambdaUrlFeature class)
- `test_lambda_url_present` — definition.lambda_url is not None
- `test_lambda_url_enabled` — definition.lambda_url.enabled is True
- `test_lambda_url_auth_type` — definition.lambda_url.auth_type == LambdaUrlAuthType.NONE

**Section 3: Handler Unit Tests** (TestHandlers class)
- `test_validate_order_valid` — valid order returns expected dict
- `test_validate_order_empty_items` — raises error for empty items
- `test_validate_order_negative_total` — raises error for negative total
- `test_process_order` — returns processed result dict

**Section 4: Full Workflow Simulation** (TestWorkflowSimulation class)
- `test_happy_path` — Submit order via MockDurableContext, verify final result contains processed order

Import patterns:
```python
from rsf.dsl.parser import load_definition
from rsf.dsl.models import TaskState, SucceedState
from rsf.dsl.types import LambdaUrlAuthType
from rsf.registry import discover_handlers, get_handler
from mock_sdk import MockDurableContext
```

Use `discover_handlers(HANDLERS_DIR)` to auto-register handlers before handler tests.
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -m pytest examples/lambda-url-trigger/tests/test_local.py -v --tb=short 2>&1 | tail -30</automated>
  </verify>
  <done>
    - conftest.py provides path setup and clean_registry fixture matching other examples
    - test_local.py has 4 test sections: parsing, lambda_url feature, handlers, simulation
    - All tests pass with `pytest examples/lambda-url-trigger/tests/test_local.py -v`
    - Tests are discovered by `pytest -m "not integration"` (no integration marker)
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest examples/lambda-url-trigger/tests/test_local.py -v` — all tests pass
2. `python -m pytest -m "not integration" --co -q 2>&1 | grep "lambda-url-trigger"` — tests are discovered
3. No tests have `@pytest.mark.integration` marker
</verification>

<success_criteria>
- All local tests pass with zero failures
- Tests cover workflow parsing, lambda_url feature, handler logic, and simulation
- Tests follow established 4-section pattern from other examples
- Tests are included in `pytest -m "not integration"` discovery
</success_criteria>

<output>
After completion, create `.planning/phases/37-example-workflow/37-02-SUMMARY.md`
</output>
