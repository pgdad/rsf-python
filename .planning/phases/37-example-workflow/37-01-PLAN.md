---
phase: 37-example-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/lambda-url-trigger/workflow.yaml
  - examples/lambda-url-trigger/handlers/__init__.py
  - examples/lambda-url-trigger/handlers/validate_order.py
  - examples/lambda-url-trigger/handlers/process_order.py
  - examples/lambda-url-trigger/README.md
autonomous: true
requirements: [EX-01]
must_haves:
  truths:
    - "examples/lambda-url-trigger/ directory exists with workflow.yaml, handlers, and README"
    - "workflow.yaml includes lambda_url: {enabled: true, auth_type: NONE} and parses without errors"
    - "Handlers are simple functions taking a dict and returning a dict, registered via @state decorator"
  artifacts:
    - path: "examples/lambda-url-trigger/workflow.yaml"
      provides: "DSL workflow definition with lambda_url feature"
      contains: "lambda_url"
    - path: "examples/lambda-url-trigger/handlers/validate_order.py"
      provides: "ValidateOrder handler"
      contains: "@state"
    - path: "examples/lambda-url-trigger/handlers/process_order.py"
      provides: "ProcessOrder handler"
      contains: "@state"
    - path: "examples/lambda-url-trigger/README.md"
      provides: "Example documentation"
  key_links:
    - from: "examples/lambda-url-trigger/workflow.yaml"
      to: "rsf.dsl.parser.load_definition"
      via: "YAML parsing"
      pattern: "lambda_url"
    - from: "examples/lambda-url-trigger/handlers/validate_order.py"
      to: "rsf.registry.state"
      via: "@state decorator"
      pattern: "@state"
---

<objective>
Create the lambda-url-trigger example directory with DSL workflow YAML, Python handlers, and README.

Purpose: Provide a working reference example that demonstrates triggering a durable execution via HTTP POST to a Lambda Function URL. This is the foundational plan — later plans add tests and Terraform.

Output: examples/lambda-url-trigger/ with workflow.yaml, handlers/, and README.md
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@examples/order-processing/workflow.yaml
@examples/order-processing/handlers/validate_order.py
@examples/order-processing/README.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/rsf/dsl/models.py:
```python
class LambdaUrlConfig(BaseModel):
    enabled: bool
    auth_type: LambdaUrlAuthType

class StateMachineDefinition(BaseModel):
    lambda_url: LambdaUrlConfig | None = Field(default=None, alias="lambda_url")
```

From src/rsf/dsl/types.py:
```python
class LambdaUrlAuthType(str, Enum):
    NONE = "NONE"
    AWS_IAM = "AWS_IAM"
```

From src/rsf/registry/__init__.py:
```python
from rsf.registry.registry import state  # decorator for registering handlers
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create workflow.yaml and handlers</name>
  <files>
    examples/lambda-url-trigger/workflow.yaml
    examples/lambda-url-trigger/handlers/__init__.py
    examples/lambda-url-trigger/handlers/validate_order.py
    examples/lambda-url-trigger/handlers/process_order.py
  </files>
  <action>
Create the `examples/lambda-url-trigger/` directory structure.

**workflow.yaml** — A simple 3-state workflow demonstrating the lambda_url feature:
```yaml
rsf_version: "1.0"
Comment: "Lambda URL trigger example — receive an order via HTTP POST, validate, process, and complete"
lambda_url:
  enabled: true
  auth_type: NONE
StartAt: ValidateOrder
States:
  ValidateOrder:
    Type: Task
    Next: ProcessOrder
  ProcessOrder:
    Type: Task
    Next: OrderComplete
  OrderComplete:
    Type: Succeed
```

Key design decisions from CONTEXT.md (locked):
- Webhook receiver pattern: receive an order event via HTTP POST
- Order event payload: `{orderId, items, total}` — familiar business domain
- 3 states: ValidateOrder (Task) -> ProcessOrder (Task) -> OrderComplete (Succeed)
- `auth_type: NONE` (public endpoint) for simplicity

**handlers/__init__.py** — Empty init file.

**handlers/validate_order.py** — Validate the order payload:
- Register with `@state("ValidateOrder")`
- Accepts dict with orderId, items, total
- Validates: items must be a non-empty list, total must be a positive number
- Returns: `{"valid": True, "orderId": orderId, "itemCount": len(items), "total": total}`
- Raises a descriptive error if validation fails
- Follow the logging pattern from `examples/order-processing/handlers/validate_order.py`

**handlers/process_order.py** — Process the validated order:
- Register with `@state("ProcessOrder")`
- Accepts dict (receives the full state including validation result)
- Returns: `{"processed": True, "orderId": orderId, "status": "completed"}`
- Follow the same handler pattern (logging, type annotations, docstring)
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && python -c "from rsf.dsl.parser import load_definition; d = load_definition('examples/lambda-url-trigger/workflow.yaml'); assert d.lambda_url is not None; assert d.lambda_url.enabled; print('OK')"</automated>
  </verify>
  <done>
    - workflow.yaml exists and parses without errors via load_definition
    - lambda_url config is present with enabled=true and auth_type=NONE
    - Both handlers exist with @state decorators and proper docstrings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create README.md</name>
  <files>examples/lambda-url-trigger/README.md</files>
  <action>
Create README.md following the established pattern from `examples/order-processing/README.md`.

Structure:
```markdown
# Lambda URL Trigger

A webhook receiver workflow demonstrating how to trigger a durable execution via HTTP POST to a Lambda Function URL.

## DSL Features Demonstrated

| Feature | Usage |
|---------|-------|
| **Task** | ValidateOrder, ProcessOrder |
| **Succeed** | OrderComplete terminal state |
| **Lambda URL** | `lambda_url: {enabled: true, auth_type: NONE}` — public HTTP endpoint |

## Workflow Path

\```
HTTP POST → Lambda URL → ValidateOrder → ProcessOrder → OrderComplete
\```

## Run Locally (No AWS)

\```bash
pytest examples/lambda-url-trigger/tests/test_local.py -v
\```

## Run Integration Test (AWS)

\```bash
pytest tests/test_examples/test_lambda_url_trigger.py -m integration -v
\```
```

Keep it concise and consistent with the other example READMEs. No screenshots section needed since this is a new example.
  </action>
  <verify>
    <automated>test -f /home/esa/git/rsf-python/examples/lambda-url-trigger/README.md && echo "OK"</automated>
  </verify>
  <done>
    - README.md exists with DSL features table, workflow path, and run instructions
    - Follows established example README pattern
  </done>
</task>

</tasks>

<verification>
1. `python -c "from rsf.dsl.parser import load_definition; d = load_definition('examples/lambda-url-trigger/workflow.yaml'); assert d.lambda_url.enabled; assert d.lambda_url.auth_type.value == 'NONE'"` succeeds
2. `ls examples/lambda-url-trigger/handlers/validate_order.py examples/lambda-url-trigger/handlers/process_order.py` all exist
3. README.md contains "Lambda URL" and run instructions
</verification>

<success_criteria>
- examples/lambda-url-trigger/ directory exists with all required files
- workflow.yaml parses successfully with lambda_url configuration
- Handlers follow established patterns (@state decorator, logging, type hints)
- README follows the existing example README template
</success_criteria>

<output>
After completion, create `.planning/phases/37-example-workflow/37-01-SUMMARY.md`
</output>
