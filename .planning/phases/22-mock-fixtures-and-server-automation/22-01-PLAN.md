---
phase: 22-mock-fixtures-and-server-automation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ui/scripts/fixtures/order-processing.json
  - ui/scripts/fixtures/approval-workflow.json
  - ui/scripts/fixtures/data-pipeline.json
  - ui/scripts/fixtures/retry-and-recovery.json
  - ui/scripts/fixtures/intrinsic-showcase.json
  - ui/scripts/mock-inspect-server.ts
autonomous: true
requirements: [CAPT-03]

must_haves:
  truths:
    - "Each of the 5 examples has a JSON fixture file containing mock execution data that matches the inspector API contract"
    - "The mock inspect server starts on a configurable port and serves fixture data via the same REST and SSE endpoints as the real inspect server"
    - "The inspector UI displays meaningful state (execution list, node overlays, event timeline) when pointed at the mock server"
  artifacts:
    - path: "ui/scripts/fixtures/order-processing.json"
      provides: "Mock execution data for order-processing workflow"
      contains: "ValidateOrder"
    - path: "ui/scripts/fixtures/approval-workflow.json"
      provides: "Mock execution data for approval-workflow"
      contains: "SubmitRequest"
    - path: "ui/scripts/fixtures/data-pipeline.json"
      provides: "Mock execution data for data-pipeline workflow"
      contains: "InitPipeline"
    - path: "ui/scripts/fixtures/retry-and-recovery.json"
      provides: "Mock execution data for retry-and-recovery workflow"
      contains: "CallPrimaryService"
    - path: "ui/scripts/fixtures/intrinsic-showcase.json"
      provides: "Mock execution data for intrinsic-showcase workflow"
      contains: "PrepareData"
    - path: "ui/scripts/mock-inspect-server.ts"
      provides: "Mock FastAPI-compatible server serving fixture data"
      min_lines: 50
  key_links:
    - from: "ui/scripts/mock-inspect-server.ts"
      to: "ui/scripts/fixtures/*.json"
      via: "fs.readFileSync loading fixture by example name"
      pattern: "readFileSync.*fixtures"
    - from: "ui/scripts/mock-inspect-server.ts"
      to: "/api/inspect/executions"
      via: "HTTP GET handler returning execution list"
      pattern: "api/inspect/executions"
    - from: "ui/scripts/mock-inspect-server.ts"
      to: "/api/inspect/execution/:id/stream"
      via: "SSE handler returning execution_info + history events"
      pattern: "api/inspect/execution"
---

<objective>
Create mock execution fixture JSON files for all 5 example workflows and a mock inspect server that serves them, so the inspector UI can display realistic execution data without any AWS connectivity.

Purpose: Phase 23 screenshot scripts need the inspector to show populated state (execution list, node overlays, event timeline). This plan provides the mock data and server to make that possible.
Output: 5 fixture JSON files in ui/scripts/fixtures/ and a mock-inspect-server.ts script that serves them.
</objective>

<execution_context>
@/home/esa/.claude/get-shit-done/workflows/execute-plan.md
@/home/esa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-playwright-setup/21-01-SUMMARY.md

Key files to reference:
@examples/order-processing/workflow.yaml
@examples/approval-workflow/workflow.yaml
@examples/data-pipeline/workflow.yaml
@examples/retry-and-recovery/workflow.yaml
@examples/intrinsic-showcase/workflow.yaml
@src/rsf/inspect/models.py
@src/rsf/inspect/router.py
@ui/src/inspector/types.ts
@ui/src/inspector/timeMachine.ts
@ui/src/inspector/useSSE.ts
@ui/src/inspector/ExecutionList.tsx

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From src/rsf/inspect/models.py (Python Pydantic models — fixture JSON must match serialized form):
```python
class ExecutionStatus(str, Enum):
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"
    STOPPED = "STOPPED"

class ExecutionSummary(BaseModel):
    execution_id: str
    name: str
    status: ExecutionStatus
    function_name: str
    start_time: datetime  # ISO 8601 string in JSON
    end_time: datetime | None

class ExecutionDetail(ExecutionSummary):
    input_payload: dict | None
    result: dict | None
    error: ExecutionError | None  # {error: str, cause: str}
    history: list[HistoryEvent]

class HistoryEvent(BaseModel):
    event_id: int
    timestamp: datetime  # ISO 8601 string in JSON
    event_type: str
    sub_type: str | None
    details: dict
```

From src/rsf/inspect/router.py (API endpoints mock server must replicate):
```
GET  /api/inspect/executions          → { executions: ExecutionSummary[], next_token: null }
GET  /api/inspect/execution/{id}      → ExecutionDetail (with history)
GET  /api/inspect/execution/{id}/history → { execution_id: str, events: HistoryEvent[] }
GET  /api/inspect/execution/{id}/stream  → SSE: event "execution_info" (detail w/o history),
                                                  event "history" (all events)
```

From ui/src/inspector/timeMachine.ts (how events map to graph overlays — CRITICAL for fixture design):
```typescript
// getStateName() extracts state name from event.details:
//   d.stateName || d.StateName || d.state_name || d.name || d.Name

// eventToStatus() maps event_type/sub_type to NodeOverlayStatus:
//   "started"/"enter" → 'running'
//   "succeeded"/"completed" → 'succeeded'
//   "failed" → 'failed'
//   "caught" → 'caught'
//   "retri" → 'running' (retrying)
```

From ui/src/inspector/useSSE.ts (SSE event names the mock server must emit):
```typescript
// SSE events:
//   "execution_info" → JSON of ExecutionDetail without history
//   "history" → JSON array of HistoryEvent[]
//   "history_update" → JSON array of new HistoryEvent[] (incremental)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock execution fixture JSON files for all 5 examples</name>
  <files>
    ui/scripts/fixtures/order-processing.json
    ui/scripts/fixtures/approval-workflow.json
    ui/scripts/fixtures/data-pipeline.json
    ui/scripts/fixtures/retry-and-recovery.json
    ui/scripts/fixtures/intrinsic-showcase.json
  </files>
  <action>
Create the directory `ui/scripts/fixtures/` and 5 JSON fixture files. Each fixture represents a COMPLETED (SUCCEEDED) execution of its workflow, with realistic history events that trace through every state in the workflow.

Each fixture JSON has this structure:
```json
{
  "executions": [
    {
      "execution_id": "exec-{example-name}-001",
      "name": "{Example Name} Run",
      "status": "SUCCEEDED",
      "function_name": "rsf-{example-name}",
      "start_time": "2026-01-15T10:00:00Z",
      "end_time": "2026-01-15T10:00:05Z"
    }
  ],
  "execution_detail": {
    "execution_id": "exec-{example-name}-001",
    "name": "{Example Name} Run",
    "status": "SUCCEEDED",
    "function_name": "rsf-{example-name}",
    "start_time": "2026-01-15T10:00:00Z",
    "end_time": "2026-01-15T10:00:05Z",
    "input_payload": { ... realistic input ... },
    "result": { ... realistic output ... },
    "error": null,
    "history": [ ... events ... ]
  }
}
```

**History events MUST follow these rules** (from timeMachine.ts):
- Each state transition produces 2 events: a "StateEntered" (sub_type: null) and a "StateSucceeded"/"StateFailed" event
- `event_type` uses "StateEntered" and "StateSucceeded" (the time machine checks for "enter"/"started" and "succeeded"/"completed" substrings)
- Each event's `details` MUST contain `stateName` key matching the exact state name from workflow.yaml
- Events should have `input` and `output` in details for states with I/O
- `event_id` is sequential starting from 1
- Timestamps are sequential ISO 8601 strings, each ~500ms apart

**Per-example fixture requirements:**

1. **order-processing.json** — States: ValidateOrder, CheckOrderValue, ProcessOrder (Parallel: ProcessPayment, ReserveInventory), SendConfirmation, OrderComplete. Use happy path (total=500, goes to ProcessOrder). Input: `{"orderId": "ORD-2026-001", "items": [{"sku": "WIDGET-A", "qty": 2, "price": 49.99}]}`. Show validation result with `total: 99.98, itemCount: 1`.

2. **approval-workflow.json** — States: SubmitRequest, SetApprovalContext, WaitForReview, CheckApprovalStatus, EvaluateDecision, ProcessApproval, RequestApproved. Use happy path (approved on first check). Input: `{"request": {"type": "purchase", "amount": 5000}, "userId": "user-42"}`.

3. **data-pipeline.json** — States: InitPipeline, FetchRecords, TransformRecords (Map: ValidateRecord, EnrichRecord), StoreResults, PipelineComplete. Input: `{"source": {"bucket": "data-lake", "prefix": "raw/2026-01"}}`.

4. **retry-and-recovery.json** — States: CallPrimaryService, VerifyResult, ServiceComplete. Use happy path (primary succeeds without retries). Input: `{"serviceUrl": "https://api.example.com/process", "payload": {"action": "transform"}}`.

5. **intrinsic-showcase.json** — States: PrepareData, StringOperations, ArrayOperations, MathAndJsonOps, CheckResults, ShowcaseComplete. Input: `{"input": {"userName": "Jane Doe"}}`. Show intrinsic function outputs in results.

Each fixture should have 1 execution in the `executions` list (for the execution list panel) and the corresponding `execution_detail` with full history events (for the detail/timeline view).
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python && node -e "
const fs = require('fs');
const examples = ['order-processing','approval-workflow','data-pipeline','retry-and-recovery','intrinsic-showcase'];
for (const ex of examples) {
  const f = JSON.parse(fs.readFileSync('ui/scripts/fixtures/' + ex + '.json', 'utf8'));
  console.assert(f.executions.length >= 1, ex + ': needs executions');
  console.assert(f.execution_detail.history.length >= 4, ex + ': needs history events');
  console.assert(f.execution_detail.status === 'SUCCEEDED', ex + ': must be SUCCEEDED');
  const states = f.execution_detail.history.map(e => e.details.stateName).filter(Boolean);
  console.assert(states.length >= 2, ex + ': history needs stateName in details');
  console.log('OK: ' + ex + ' (' + f.execution_detail.history.length + ' events, states: ' + [...new Set(states)].join(', ') + ')');
}
console.log('All fixture validations passed.');
"</automated>
  </verify>
  <done>5 fixture JSON files exist in ui/scripts/fixtures/ with realistic execution data. Each has an executions array, an execution_detail with history events covering the happy-path state transitions, and all events contain stateName in details matching exact state names from each workflow.yaml.</done>
</task>

<task type="auto">
  <name>Task 2: Create mock inspect server that serves fixture data</name>
  <files>ui/scripts/mock-inspect-server.ts</files>
  <action>
Create `ui/scripts/mock-inspect-server.ts` — a lightweight HTTP server using Node's built-in `http` module (no external dependencies) that serves mock execution data from the fixture JSON files.

**Server behavior:**
- Accepts CLI args: `--fixture <example-name>` and `--port <number>` (default 8766)
- On startup, loads the fixture file from `ui/scripts/fixtures/{example-name}.json`
- Implements these endpoints (matching the real inspect server's API):

  1. `GET /api/inspect/executions` → Returns `{ executions: [...], next_token: null }` from fixture
  2. `GET /api/inspect/execution/{id}` → Returns the `execution_detail` object from fixture
  3. `GET /api/inspect/execution/{id}/history` → Returns `{ execution_id, events }` from fixture
  4. `GET /api/inspect/execution/{id}/stream` → SSE response:
     - Set headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`
     - Send `event: execution_info\ndata: {detail without history}\n\n`
     - Send `event: history\ndata: {history array}\n\n`
     - Close the connection (fixture is terminal/SUCCEEDED)

- CORS headers on all responses: `Access-Control-Allow-Origin: *`
- Console output on start: `Mock inspect server started on port {port} (fixture: {example})`
- Console output per request: `{method} {url}` for debugging
- Graceful shutdown on SIGINT/SIGTERM

**Script execution pattern** (matching Phase 21 pattern):
```
node --import tsx/esm scripts/mock-inspect-server.ts --fixture order-processing --port 8766
```

**Key implementation details:**
- Use `import { createServer } from 'node:http'` and `import { readFileSync } from 'node:fs'`
- Parse URL with `new URL(req.url, 'http://localhost')`
- For SSE endpoint, write raw SSE frames (not using any library)
- The execution_detail in fixture already has the `history` field — when serving via the non-SSE endpoint, return it as-is; for SSE `execution_info` event, strip the `history` field before serializing
- Handle 404 for unknown routes with `{ error: "Not found" }`
  </action>
  <verify>
    <automated>cd /home/esa/git/rsf-python/ui && timeout 10 bash -c '
node --import tsx/esm scripts/mock-inspect-server.ts --fixture order-processing --port 18766 &
PID=$!
sleep 2
RESP=$(curl -s http://127.0.0.1:18766/api/inspect/executions)
echo "Executions response: $RESP"
EXEC_ID=$(echo $RESP | node -e "process.stdin.setEncoding(\"utf8\"); let d=\"\"; process.stdin.on(\"data\",c=>d+=c); process.stdin.on(\"end\",()=>console.log(JSON.parse(d).executions[0].execution_id))")
echo "Execution ID: $EXEC_ID"
DETAIL=$(curl -s http://127.0.0.1:18766/api/inspect/execution/$EXEC_ID)
echo "Detail has history: $(echo $DETAIL | node -e "process.stdin.setEncoding(\"utf8\"); let d=\"\"; process.stdin.on(\"data\",c=>d+=c); process.stdin.on(\"end\",()=>console.log(JSON.parse(d).history.length))" ) events"
SSE=$(curl -s -N --max-time 3 http://127.0.0.1:18766/api/inspect/execution/$EXEC_ID/stream 2>/dev/null || true)
echo "SSE contains execution_info: $(echo "$SSE" | grep -c "event: execution_info")"
echo "SSE contains history: $(echo "$SSE" | grep -c "event: history")"
kill $PID 2>/dev/null
echo "Mock inspect server test PASSED"
' 2>&1 || echo "Test completed (timeout is expected for SSE)"</automated>
  </verify>
  <done>mock-inspect-server.ts starts on a configurable port, loads a fixture file by example name, and serves all 4 inspector API endpoints (executions list, execution detail, execution history, SSE stream) with the correct data formats matching what the real inspect server returns.</done>
</task>

</tasks>

<verification>
1. All 5 fixture JSON files parse without errors and contain expected structure
2. Mock inspect server starts, serves data from fixture files, and responds to all 4 API endpoints
3. Fixture history events have stateName in details (required by timeMachine.ts for graph overlays)
4. Fixture event_types use "StateEntered"/"StateSucceeded" patterns (required by timeMachine.ts eventToStatus())
</verification>

<success_criteria>
- 5 fixture files exist in ui/scripts/fixtures/ with realistic execution data for each example workflow
- mock-inspect-server.ts starts and serves fixture data on all 4 API endpoints
- Fixture data format matches the inspector types (ExecutionSummary, ExecutionDetail, HistoryEvent)
- History events contain stateName in details and use event_type patterns that timeMachine.ts recognizes
</success_criteria>

<output>
After completion, create `.planning/phases/22-mock-fixtures-and-server-automation/22-01-SUMMARY.md`
</output>
