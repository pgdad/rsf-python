# Tutorial 3: Code Generation with `rsf generate`

## What You'll Learn

In this tutorial you will:

- Run `rsf generate` on a validated workflow and get a working orchestrator file plus handler stubs
- Explore the generated file structure and understand what each file does
- Understand how the `@state` decorator connects handler functions to workflow states
- Generate code from a multi-state workflow and see one handler stub created per Task state
- Customize a generated handler stub with your own business logic
- Re-generate without losing your changes, using the Generation Gap pattern

---

## Prerequisites

- Completed Tutorials 1 and 2: you have a `my-workflow/` directory with a validated `workflow.yaml`
- RSF is installed and the `rsf` command is available

If you need to start fresh:

```bash
rsf init my-workflow
cd my-workflow
```

Make sure you are inside the `my-workflow/` directory for all commands in this tutorial.

---

## Step 1: Generate Code from the Starter Workflow

Run `rsf generate` with no arguments:

```bash
rsf generate
```

Expected output:

```
Generated: orchestrator.py
  Skipped: handlers/example_handler.py (already exists, not overwritten)

Summary: orchestrator written, 0 handler(s) created, 1 skipped.
```

Two things happened:

1. **orchestrator.py** was generated in the current directory. This file contains the state machine execution logic derived from `workflow.yaml`.
2. **handlers/example_handler.py** was skipped. It already exists (created by `rsf init` in Tutorial 1), and RSF will not overwrite a handler file that you may have edited. This is the Generation Gap pattern, explained in Step 5.

> `rsf generate` validates your workflow before generating code. It runs the same 3-stage validation pipeline as `rsf validate`. If your workflow has errors, generation stops and you see the same error messages from Tutorial 2.

---

## Step 2: Explore the Generated Files

Your project directory now looks like this:

```
my-workflow/
├── orchestrator.py          <-- NEW: generated orchestrator
├── workflow.yaml
├── pyproject.toml
├── .gitignore
├── handlers/
│   ├── __init__.py           <-- UPDATED: auto-generated imports
│   └── example_handler.py    <-- UNCHANGED: skipped by Generation Gap
└── tests/
    ├── __init__.py
    └── test_example.py
```

The new and modified files are:

- **orchestrator.py** — the generated orchestrator that implements the state machine logic from `workflow.yaml`. This file is always regenerated.
- **handlers/__init__.py** — updated with auto-generated import statements for all Task state handlers. The orchestrator uses these imports to find your handler functions.

---

## Understanding the Orchestrator

The generated `orchestrator.py` starts with a header like this:

```python
# DO NOT EDIT - Generated by RSF v0.1.0 on 2026-02-26T12:00:00Z
# Source: workflow.yaml (SHA-256: abc123...)
```

Key things to know about the orchestrator:

- The `# DO NOT EDIT - Generated by RSF` marker on line 1 tells RSF that this file is managed. It will be overwritten every time you run `rsf generate`. Never edit this file — your changes will be lost.
- The orchestrator imports handler functions from the `handlers/` package. When you add Task states to your workflow, `rsf generate` adds the corresponding imports.
- The `lambda_handler` function is the Lambda entry point. It receives the execution event and walks through states defined in `workflow.yaml`, calling the registered handler function for each Task state.
- The state machine logic (routing, Choice evaluation, error handling) is generated from your workflow definition. You never need to write this code yourself.

> The exact content of `orchestrator.py` depends on your workflow definition and includes timestamps and hash values. Do not try to match it line-for-line. What matters is the structure: header, imports, handler, state machine loop.

---

## Understanding Handler Stubs

The handler file `handlers/example_handler.py` was created by `rsf init` in Tutorial 1. Open it to review:

```python
"""Example RSF handler using the @state decorator."""

from rsf.functions.decorators import state


@state("HelloWorld")
def hello_world(event: dict, context: dict) -> dict:
    """Handle the HelloWorld state.

    Args:
        event: The input event for this state.
        context: The Lambda execution context.

    Returns:
        The output to pass to the next state.
    """
    name = event.get("name", "World")
    return {"message": f"Hello, {name}!"}
```

The key elements:

- **`@state("HelloWorld")`** — this decorator registers the function as the handler for the `HelloWorld` state in `workflow.yaml`. The string must match the state name exactly (case-sensitive).
- **Function signature** — the function receives `event` (the input data for this state) and `context` (Lambda execution metadata). The return value becomes the output passed to the next state.
- **Business logic** — this is where your code lives. The example reads a `name` from the event and returns a greeting. Replace this with whatever your state needs to do.

> When `rsf generate` creates a new handler stub for a Task state, the stub contains a `NotImplementedError` placeholder. Replace the placeholder with your business logic, keeping the `@state` decorator and function signature intact.

---

## Step 3: Generate Code from a Multi-State Workflow

The starter workflow only has Pass and Succeed states, so only the example handler (created by `rsf init`) was relevant. To see `rsf generate` create handler stubs, you need Task states.

Replace the entire contents of `workflow.yaml` with this order processing workflow:

```yaml
rsf_version: "1.0"
Comment: "Order processing workflow"
StartAt: ValidateOrder

States:
  ValidateOrder:
    Type: Task
    Next: CheckAmount

  CheckAmount:
    Type: Choice
    Choices:
      - Variable: "$.amount"
        NumericGreaterThan: 100
        Next: RequireApproval
    Default: ProcessOrder

  RequireApproval:
    Type: Task
    Next: ProcessOrder

  ProcessOrder:
    Type: Task
    End: true
```

This workflow has four states:

- **ValidateOrder** — a Task state that validates the incoming order
- **CheckAmount** — a Choice state that routes based on the order amount
- **RequireApproval** — a Task state for orders over 100
- **ProcessOrder** — a Task state that processes the order (terminal state)

Run `rsf generate`:

```bash
rsf generate
```

Expected output:

```
Generated: orchestrator.py
  Created: handlers/validate_order.py
  Created: handlers/require_approval.py
  Created: handlers/process_order.py

Summary: orchestrator written, 3 handler(s) created, 0 skipped.
```

Three handler stubs were created — one for each Task state. The Choice state (`CheckAmount`) does not get a handler because Choice states are routing logic handled entirely by the orchestrator. Only Task states get handler stubs.

> Handler file names are the snake_case version of the state name: `ValidateOrder` becomes `validate_order.py`, `RequireApproval` becomes `require_approval.py`.

Your directory now looks like this:

```
my-workflow/
├── orchestrator.py
├── workflow.yaml
├── pyproject.toml
├── .gitignore
├── handlers/
│   ├── __init__.py
│   ├── example_handler.py
│   ├── validate_order.py     <-- NEW
│   ├── require_approval.py   <-- NEW
│   └── process_order.py      <-- NEW
└── tests/
    ├── __init__.py
    └── test_example.py
```

---

## Step 4: Customize a Handler

Open `handlers/validate_order.py` to see the generated stub:

```python
"""Handler for the ValidateOrder task state."""

from rsf.registry import state


@state("ValidateOrder")
def validate_order(input_data: dict) -> dict:
    """Handler for the ValidateOrder task state.

    Implement your business logic here.
    """
    raise NotImplementedError("Implement ValidateOrder handler")
```

The stub has a `NotImplementedError` placeholder. Replace the entire function body with real business logic:

```python
"""Handler for the ValidateOrder task state."""

from rsf.registry import state


@state("ValidateOrder")
def validate_order(input_data: dict) -> dict:
    """Validate the incoming order.

    Checks that order_id is present and amount is non-negative.
    """
    order_id = input_data.get("order_id")
    amount = input_data.get("amount", 0)
    if not order_id:
        raise ValueError("Missing order_id")
    return {"order_id": order_id, "amount": amount, "validated": True}
```

This handler:

- Reads `order_id` and `amount` from the input data
- Raises an error if `order_id` is missing
- Returns a dict with the validated fields plus a `validated` flag

The `@state("ValidateOrder")` decorator is unchanged — it still connects this function to the `ValidateOrder` state. The function name and signature are unchanged too. Only the body is different. This is now your code.

---

## Step 5: Re-generate Without Losing Changes (Generation Gap)

Run `rsf generate` again:

```bash
rsf generate
```

Expected output:

```
Generated: orchestrator.py
  Skipped: handlers/validate_order.py (already exists, not overwritten)
  Skipped: handlers/require_approval.py (already exists, not overwritten)
  Skipped: handlers/process_order.py (already exists, not overwritten)

Summary: orchestrator written, 0 handler(s) created, 3 skipped.
```

This demonstrates the **Generation Gap** pattern:

- **orchestrator.py was regenerated.** It always is. The `# DO NOT EDIT - Generated by RSF` marker on line 1 tells RSF that this file is managed and safe to overwrite. The orchestrator is pure generated code — you never edit it.
- **All three handler stubs were skipped.** They already exist on disk and do not have the generated marker (you removed it when you edited `validate_order.py`, and the other two stubs were created without it after initial generation). RSF will never overwrite a handler file that you may have modified.
- **Your edits to `validate_order.py` are safe.** The custom business logic you wrote in Step 4 is untouched.

The Generation Gap pattern means you can freely re-run `rsf generate` whenever you change `workflow.yaml`:

- If you **add a new Task state**, `rsf generate` creates a stub for it while leaving existing handlers untouched.
- If you **rename a state**, `rsf generate` creates a new stub with the new name. The old handler file remains on disk (you can delete it manually or migrate the code).
- If you **remove a Task state**, the handler file is not deleted — it stays on disk but is no longer imported by the orchestrator.

> The rule is simple: RSF generates, you customize, RSF never overwrites your customizations.

---

## What's Next

Continue to **Tutorial 4: Deploying to AWS with `rsf deploy`**.

Tutorial 4 takes the generated orchestrator and handler code and deploys it to a real AWS account using Terraform. The `rsf deploy` command handles everything: code generation, Terraform file generation, and `terraform apply`. You will have a live Lambda Durable Function running in AWS.

The full workflow so far:

```
rsf init       → scaffold project
rsf validate   → check workflow YAML
rsf generate   → create orchestrator + handler stubs
rsf deploy     → deploy to AWS (Tutorial 4)
```

**Always validate before generating, always generate before deploying.** Each command builds on the output of the previous one.
