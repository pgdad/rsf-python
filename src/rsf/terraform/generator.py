"""Terraform HCL file generator for RSF workflows.

Generates a complete Terraform module:
- main.tf — Lambda function with durable_config
- variables.tf — Validated input variables
- iam.tf — IAM role and policy (3 statements)
- outputs.tf — Function ARN, name, role ARN, log group
- cloudwatch.tf — Log group with configurable retention
- backend.tf — Optional S3 remote state
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from rsf.terraform.engine import render_hcl_template

GENERATED_MARKER = "# DO NOT EDIT - Generated by RSF"

# The 6 HCL files that make up a complete Terraform module
TEMPLATE_FILES = {
    "main.tf": "main.tf.j2",
    "variables.tf": "variables.tf.j2",
    "iam.tf": "iam.tf.j2",
    "outputs.tf": "outputs.tf.j2",
    "cloudwatch.tf": "cloudwatch.tf.j2",
    "backend.tf": "backend.tf.j2",
}


@dataclass
class TerraformConfig:
    """Configuration for Terraform generation."""

    workflow_name: str
    aws_region: str = "us-east-1"
    name_prefix: str = "rsf"
    backend_bucket: str | None = None
    backend_key: str | None = None
    backend_dynamodb_table: str | None = None


@dataclass
class TerraformResult:
    """Result of Terraform generation."""

    generated_files: list[Path] = field(default_factory=list)
    skipped_files: list[Path] = field(default_factory=list)


def generate_terraform(
    config: TerraformConfig,
    output_dir: Path,
) -> TerraformResult:
    """Generate all Terraform files for a workflow.

    Args:
        config: Terraform generation configuration.
        output_dir: Directory to write Terraform files.

    Returns:
        TerraformResult with paths of created/skipped files.
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    resource_id = sanitize_name(config.workflow_name)
    backend_key = config.backend_key or f"rsf/{config.workflow_name}/terraform.tfstate"

    context = {
        "resource_id": resource_id,
        "workflow_name": config.workflow_name,
        "aws_region": config.aws_region,
        "name_prefix": config.name_prefix,
        "backend_bucket": config.backend_bucket,
        "backend_key": backend_key,
        "backend_dynamodb_table": config.backend_dynamodb_table,
    }

    result = TerraformResult()

    for filename, template_name in TEMPLATE_FILES.items():
        file_path = output_dir / filename
        if _should_overwrite(file_path):
            content = render_hcl_template(template_name, **context)
            file_path.write_text(content, encoding="utf-8")
            result.generated_files.append(file_path)
        else:
            result.skipped_files.append(file_path)

    return result


def sanitize_name(name: str) -> str:
    """Convert PascalCase/kebab-case/camelCase to a valid Terraform identifier.

    Terraform identifiers must start with a letter or underscore, and may
    contain letters, digits, underscores, and hyphens. We produce lowercase
    with underscores for consistency.

    Examples:
        MyWorkflow -> my_workflow
        my-workflow -> my_workflow
        ProcessOrderV2 -> process_order_v2
    """
    # Replace hyphens with underscores
    s = name.replace("-", "_")
    # Insert underscore before uppercase letters following lowercase/digit
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    # Insert underscore between consecutive uppercase and following lowercase
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", s)
    s = s.lower()
    # Collapse multiple underscores
    s = re.sub(r"_+", "_", s)
    # Strip leading/trailing underscores
    s = s.strip("_")
    # Ensure starts with letter or underscore
    if s and not s[0].isalpha() and s[0] != "_":
        s = f"_{s}"
    return s


def derive_iam_statements() -> list[dict[str, Any]]:
    """Derive the 3 base IAM policy statements for a durable Lambda function.

    Returns exactly 3 statements:
    1. CloudWatch Logs — create log groups/streams, put events
    2. Lambda self-invoke — for durable execution callbacks
    3. Durable execution — checkpoint, get, list operations
    """
    return [
        {
            "sid": "CloudWatchLogs",
            "actions": [
                "logs:CreateLogGroup",
                "logs:CreateLogStream",
                "logs:PutLogEvents",
            ],
        },
        {
            "sid": "LambdaSelfInvoke",
            "actions": [
                "lambda:InvokeFunction",
            ],
        },
        {
            "sid": "DurableExecution",
            "actions": [
                "lambda:CheckpointDurableExecution",
                "lambda:GetDurableExecution",
                "lambda:ListDurableExecutionsByFunction",
            ],
        },
    ]


def _should_overwrite(path: Path) -> bool:
    """Return True if path doesn't exist OR first line matches the generated marker.

    Implements the Generation Gap pattern for Terraform files.
    """
    if not path.exists():
        return True
    first_line = path.read_text(encoding="utf-8").split("\n", 1)[0]
    return first_line.strip().startswith(GENERATED_MARKER)
