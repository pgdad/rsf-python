"""Code generator: produces orchestrator and handler stubs from DSL definitions.

Orchestrates the full pipeline:
1. Parse DSL → StateMachineDefinition
2. Map states → SDK primitives via BFS
3. Render orchestrator template
4. Create handler stubs (Generation Gap)
"""

from __future__ import annotations

import hashlib
import re
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from rsf.codegen.emitter import emit_state_block
from rsf.codegen.engine import render_template
from rsf.codegen.state_mappers import StateMapping, map_states
from rsf.dsl.models import StateMachineDefinition

GENERATED_MARKER = "# DO NOT EDIT - Generated by RSF"


@dataclass
class StateBlock:
    """Pre-rendered code block for a single state in the orchestrator."""

    name: str
    code: str


@dataclass
class GenerationResult:
    """Result of code generation."""

    orchestrator_path: Path
    handler_paths: list[Path]
    skipped_handlers: list[Path]


def generate(
    definition: StateMachineDefinition,
    dsl_path: Path,
    output_dir: Path,
    handlers_dir: Path | None = None,
    rsf_version: str = "0.1.0",
) -> GenerationResult:
    """Generate orchestrator and handler stubs from a workflow definition.

    Args:
        definition: The parsed workflow definition.
        dsl_path: Path to the source DSL file (for hash and header comment).
        output_dir: Directory to write the orchestrator file.
        handlers_dir: Directory to write handler stubs (default: output_dir/handlers).
        rsf_version: RSF version string for the header.

    Returns:
        GenerationResult with paths of created/skipped files.
    """
    if handlers_dir is None:
        handlers_dir = output_dir / "handlers"

    # Map states via BFS traversal
    mappings = map_states(definition)

    # Generate orchestrator
    orchestrator_code = render_orchestrator(
        definition=definition,
        mappings=mappings,
        dsl_path=dsl_path,
        rsf_version=rsf_version,
    )

    output_dir.mkdir(parents=True, exist_ok=True)
    orchestrator_path = output_dir / "orchestrator.py"
    orchestrator_path.write_text(orchestrator_code, encoding="utf-8")

    # Generate handler stubs
    handler_paths: list[Path] = []
    skipped_handlers: list[Path] = []
    task_mappings = [m for m in mappings if m.state_type == "Task"]

    if task_mappings:
        handlers_dir.mkdir(parents=True, exist_ok=True)
        _ensure_handlers_init(handlers_dir, task_mappings)

        for mapping in task_mappings:
            handler_path = handlers_dir / f"{_to_snake_case(mapping.state_name)}.py"
            if _should_overwrite(handler_path):
                stub_code = render_handler_stub(mapping.state_name)
                handler_path.write_text(stub_code, encoding="utf-8")
                handler_paths.append(handler_path)
            else:
                skipped_handlers.append(handler_path)

    return GenerationResult(
        orchestrator_path=orchestrator_path,
        handler_paths=handler_paths,
        skipped_handlers=skipped_handlers,
    )


def render_orchestrator(
    definition: StateMachineDefinition,
    mappings: list[StateMapping],
    dsl_path: Path,
    rsf_version: str = "0.1.0",
) -> str:
    """Render the orchestrator Python file from mappings.

    Args:
        definition: The parsed workflow definition.
        mappings: BFS-ordered state mappings.
        dsl_path: Path to the source DSL file.
        rsf_version: RSF version string.

    Returns:
        The complete orchestrator Python source code.
    """
    # Compute DSL hash
    dsl_content = dsl_path.read_bytes() if dsl_path.exists() else b""
    dsl_hash = hashlib.sha256(dsl_content).hexdigest()

    # Pre-render state code blocks
    state_blocks = []
    for mapping in mappings:
        code = emit_state_block(mapping, indent=3)
        state_blocks.append(StateBlock(name=mapping.state_name, code=code))

    # Build handler imports for Task states
    task_names = [m.state_name for m in mappings if m.state_type == "Task"]
    handler_imports = [f"handlers.{_to_snake_case(name)}" for name in task_names]

    return render_template(
        "orchestrator.py.j2",
        rsf_version=rsf_version,
        timestamp=datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
        dsl_file=str(dsl_path),
        dsl_hash=dsl_hash,
        start_at=definition.start_at,
        state_blocks=state_blocks,
        handler_imports=handler_imports,
        mappings=mappings,
    )


def render_handler_stub(state_name: str) -> str:
    """Render a handler stub file for a Task state.

    Args:
        state_name: The PascalCase state name.

    Returns:
        The handler stub Python source code.
    """
    function_name = _to_snake_case(state_name)
    return render_template(
        "handler_stub.py.j2",
        state_name=state_name,
        function_name=function_name,
    )


def _should_overwrite(path: Path) -> bool:
    """Return True if path doesn't exist OR first line matches the generated marker.

    This implements the Generation Gap pattern:
    - Files with the marker are always regenerated (orchestrator)
    - Files without the marker (user-modified) are never touched (handlers)
    """
    if not path.exists():
        return True
    first_line = path.read_text(encoding="utf-8").split("\n", 1)[0]
    return first_line.strip().startswith(GENERATED_MARKER)


def _to_snake_case(name: str) -> str:
    """Convert PascalCase or camelCase to snake_case."""
    # Insert underscore before uppercase letters that follow lowercase
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", name)
    # Insert underscore between consecutive uppercase and following lowercase
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", s)
    return s.lower()


def _ensure_handlers_init(handlers_dir: Path, task_mappings: list[StateMapping]) -> None:
    """Create or update handlers/__init__.py with imports for all task handlers."""
    init_path = handlers_dir / "__init__.py"
    lines = [f'"""Auto-generated handler imports."""', ""]
    for m in task_mappings:
        module = _to_snake_case(m.state_name)
        lines.append(f"from handlers.{module} import {module}  # noqa: F401")
    lines.append("")
    init_path.write_text("\n".join(lines), encoding="utf-8")
